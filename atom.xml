<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Ivan's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yeziahehe.com/"/>
  <updated>2017-07-19T15:12:48.000Z</updated>
  <id>http://yeziahehe.com/</id>
  
  <author>
    <name><![CDATA[叶帆]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[利用 Background Fetch + UNUserNotificationCenter 实现伪推送]]></title>
    <link href="http://yeziahehe.com/2017/07/19/Background_Fetch_and_UNUserNotificationCenter/"/>
    <id>http://yeziahehe.com/2017/07/19/Background_Fetch_and_UNUserNotificationCenter/</id>
    <published>2017-07-19T15:12:46.000Z</published>
    <updated>2017-07-19T15:12:48.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p><strong>Tips：UNUserNotificationCenter 从 iOS 10 开始支持，低于版本的本地推送请自行谷歌。</strong></p>
<p>最近项目里面利用了第三方的 API，由干货集中营提供每日干货。由于没办法实现远程推送，考虑通过本地推送 + 后台获取的方式来实现【伪推送】，其实很多第三方的客户端，如微博的第三方客户端 Moke、奇点，HIPDA 论坛的第三方客户端，都是采用这样的方式进行推送的。如果有自己仿写第三方客户端的小伙伴，不妨试试这个方式来为你的 App 添加上推送（wei）功能。</p>
<h1 id="Background_Fetch"><a href="#Background_Fetch" class="headerlink" title="Background Fetch"></a>Background Fetch</h1><p>Background Fetch 是 Apple 官方在 iOS 7 推出的来后台刷新，提高用户体验的新方法。首先先参照苹果官方文档 <a href="https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/BackgroundExecution/BackgroundExecution.html" target="_blank" rel="external">Background Execution</a>，后台获取干的事情就是在用户打开应用之前就使app有机会执行代码来获取数据，刷新UI，极大的提高了用户体验。</p>
<p>如何实现该功能呢？</p>
<h2 id="u5F00_u542F_u540E_u53F0_u83B7_u53D6"><a href="#u5F00_u542F_u540E_u53F0_u83B7_u53D6" class="headerlink" title="开启后台获取"></a>开启后台获取</h2><p>Targets - [Project] - Capabilities - Background Modes - Background fetch，即告诉系统应用开启后台获取的权限。</p>
<p><img src="http://7xkvt5.com1.z0.glb.clouddn.com/blog/xcode_background_fetch.jpg" alt="Background fetch"></p>
<h2 id="u8BBE_u7F6E_u65F6_u95F4_u95F4_u9694"><a href="#u8BBE_u7F6E_u65F6_u95F4_u95F4_u9694" class="headerlink" title="设置时间间隔"></a>设置时间间隔</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">UIApplication</span>.shared.setMinimumBackgroundFetchInterval(<span class="type">UIApplicationBackgroundFetchIntervalMinimum</span>)</div></pre></td></tr></table></figure>
<p>默认的值是 <code>UIApplicationBackgroundFetchIntervalNever</code>，这种情况下是不会使用后台获取。<code>setMinimumBackgroundFetchInterval</code> 的值除了提供的集合之外，任意的 NSTimeInterval 都可以设置。如果设置值，那么你能在应用中看到 <strong>后台应用刷新</strong> 是打开状态。</p>
<p><img src="http://7xkvt5.com1.z0.glb.clouddn.com/blog/back_refresh.jpeg?imageView2/2/h/750" alt="后台刷新"></p>
<p>有人会问你把时间设置到最小，那么是不是应用时时刻刻都在刷新数据。答案显然不是！以 iOS 系统的脾气，当然不会让你这么为所欲为。那么，刷新的时机是什么时候？完全取决与系统。可能是你打开微信刷朋友圈的时候，帮你刷新一下；也可能单独为你唤醒设备来刷新一下。其实后来发现系统会记录我们的行为习惯，将获取刷新的时间调整到符合你行为习惯的时间。不过我们暂且不管获取的时机，应该根据应用的实际情况来进行时间间隔设置，毕竟用这个来做伪推送，那么推送刷新的及时性不是那么强，所以尽可能的长或许是个不错的选择。甚至于我在 App 中是跟用户讲清楚了机制，并且用户可以选择关闭或者开启，以及设置间隔时长。</p>
<h2 id="u5B9E_u73B0"><a href="#u5B9E_u73B0" class="headerlink" title="实现"></a>实现</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, performFetchWithCompletionHandler completionHandler: @escaping <span class="params">(UIBackgroundFetchResult)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">  <span class="keyword">if</span> <span class="type">GankUserDefaults</span>.isBackgroundEnable.value == <span class="literal">false</span> &#123;</div><div class="line">      completionHandler(.noData)</div><div class="line">      <span class="keyword">return</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="type">GankBackgroundFetchService</span>.shared.performFetchWithCompletionHandler &#123; (result) <span class="keyword">in</span></div><div class="line">      <span class="type">SafeDispatch</span>.async &#123;</div><div class="line">          completionHandler(result)</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AppDelegate 中的 <code>-application:performFetchWithCompletionHandler:</code> 方法来实现处理，你想通这边处理的数据、UI 和你在其他地方一样，唯一限制的就是时间不能超过 1 分钟，比如大图片的上传下载这种操作不要放在这边处理。CompletionHandler 会接受到 <code>UIBackgroundFetchResult</code> 闭包值，可选结果有 <code>.noData</code>、<code>.newData</code>、<code>.failed</code> 三种情况。</p>
<h2 id="u8C03_u8BD5"><a href="#u8C03_u8BD5" class="headerlink" title="调试"></a>调试</h2><p>关于调试，分为两种情况。一种是通过 Background Fetch 直接打开应用，另一种是应用在后台的时候模拟一次 Background Fetch 的情况。这边我只提供第二种测试方案，第一种相对麻烦，我后台通过真机测试了下。第二种情况跑通能且只能说明 Background Fetch 没有问题了。但是直接打开应用对数据的处理，确实需要第一种情况测试下，这边提供喵神的文章 <a href="https://onevcat.com/2013/08/ios7-background-multitask/" target="_blank" rel="external">WWDC 2013 Session笔记 - iOS7中的多任务</a> 作为参考。</p>
<p>模拟后台运行，只需要选择 Xcode 的 Debug - Simulate Background Fetch，即可模拟一次。</p>
<p><img src="http://7xkvt5.com1.z0.glb.clouddn.com/blog/debug.png" alt="Debug"></p>
<h1 id="UNUserNotificationCenter"><a href="#UNUserNotificationCenter" class="headerlink" title="UNUserNotificationCenter"></a>UNUserNotificationCenter</h1><p>接下来我们来聊聊推送的事情，那天我看了下 iOS 的推送，从 iOS 7 开始苹果为了整合推送的 API 和易用性，做了大量的调整，几乎一个版本一个花样，可以想象到激光推送这样的三方推送平台内心是崩溃的。</p>
<p>关于推送问题，这里不做过多的赘述，因为只是使用了最简单的本地推送，如果你对推送新特性有兴趣，同样推荐喵神的文章 <a href="https://onevcat.com/2016/08/notification/" target="_blank" rel="external">活久见的重构 - iOS 10 UserNotifications 框架解析</a> 作为参考，写的非常细致。</p>
<p>我这边直接讲解推送和后台刷新结合的问题，刚刚说到在 <code>-application:performFetchWithCompletionHandler:</code> 方法来实现处理。我给了一个 <code>UserDefaults</code> 讲是否是今天的日期存储下来，从来来决定是否推送。注意大家要根据实际情况来进行处理，我这边内容一天只会更新一次。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">checkAuthorization</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="type">UNUserNotificationCenter</span>.current().getNotificationSettings(completionHandler: &#123; settings <span class="keyword">in</span></div><div class="line">        <span class="type">SafeDispatch</span>.async &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></div><div class="line">            <span class="keyword">switch</span> settings.authorizationStatus &#123;</div><div class="line">            <span class="keyword">case</span> .notDetermined:</div><div class="line">                <span class="keyword">self</span>?.authorize()</div><div class="line">            <span class="keyword">case</span> .authorized:</div><div class="line">                gankLog.debug(<span class="string">"UserNotifications authorized"</span>)</div><div class="line">            <span class="keyword">case</span> .denied:</div><div class="line">                <span class="type">UIApplication</span>.shared.<span class="keyword">open</span>(<span class="type">URL</span>(string: <span class="type">UIApplicationOpenSettingsURLString</span>)!, options: [:], completionHandler: <span class="literal">nil</span>)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过 <code>getNotificationSettings</code> 来进行当前 Notication 状态的获取，从来进行操作。一共有三种状态 <code>.notDetermined</code>、<code>.authorized</code>、<code>.denied</code>，分别对应着仍未询问、已授权和已拒绝。可以看到我分别做了处理，未询问去进行授权提醒，而已经拒绝，可以通过方法跳转到应用的设置页面，即上面后台刷新那张图中进行状态的修改。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">authorize</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="type">UNUserNotificationCenter</span>.current().requestAuthorization(options: [.alert, .sound]) &#123; (granted, error) <span class="keyword">in</span></div><div class="line">        <span class="type">SafeDispatch</span>.async &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></div><div class="line">            <span class="keyword">self</span>?.initAuthorization()</div><div class="line">            <span class="keyword">if</span> granted &#123;</div><div class="line">                gankLog.debug(<span class="string">"UserNotifications authorized"</span>)</div><div class="line">                <span class="type">GankBackgroundFetchService</span>.shared.turnOn()</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                gankLog.debug(<span class="string">"UserNotifications denied"</span>)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过 <code>requestAuthorization</code> 进行推送权限获取，注意这边获取如果用户拒绝了，那么不管你之后怎么调用这个方法，询问权限获取的弹窗都不会再出现。所以一定要注意询问的时期，最好不要再一打开 App 就进行询问，很容易被用户进行拒绝。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> content = <span class="type">UNMutableNotificationContent</span>()</div><div class="line">content.title = <span class="type">String</span>.titleContentTitle</div><div class="line">content.body = <span class="type">String</span>.messageTodayGank</div><div class="line">content.sound = <span class="type">UNNotificationSound</span>.<span class="keyword">default</span>()</div><div class="line"><span class="keyword">let</span> trigger = <span class="type">UNTimeIntervalNotificationTrigger</span>(timeInterval: <span class="number">1</span>, repeats: <span class="literal">false</span>)</div><div class="line"><span class="keyword">let</span> requestIdentifier = <span class="string">"gank update"</span></div><div class="line"><span class="keyword">let</span> request = <span class="type">UNNotificationRequest</span>(identifier: requestIdentifier, content: content, trigger: trigger)</div><div class="line"><span class="type">UNUserNotificationCenter</span>.current().add(request, withCompletionHandler: <span class="literal">nil</span>)</div></pre></td></tr></table></figure>
<p>最后发送推送，这边给的是最基础的推送内容。</p>
<h1 id="u6700_u540E"><a href="#u6700_u540E" class="headerlink" title="最后"></a>最后</h1><p>到此，通过 Background Fetch + UNUserNotificationCenter 实现伪推送就都完成了。这两个部分我都封装了 Service：<a href="https://github.com/yeziahehe/Gank/blob/master/Gank/Services/GankBackgroundFetchService.swift" target="_blank" rel="external">GankBackgroundFetchService</a> 和 <a href="https://github.com/yeziahehe/Gank/blob/master/Gank/Services/GankNotificationService.swift" target="_blank" rel="external">GankNotificationService</a>，希望对你有帮助。</p>
<blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt=""><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2017/07/19/Background_Fetch_and_UNUserNotificationCenter/">http://yeziahehe.com/2017/07/19/Background_Fetch_and_UNUserNotificationCenter/</a></blockquote>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p><strong>Tips：UNUserNotif]]>
    </summary>
    
      <category term="iOS" scheme="http://yeziahehe.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://yeziahehe.com/tags/Swift/"/>
    
      <category term="技术" scheme="http://yeziahehe.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用 UIFeedbackGenerator 来实现触觉反馈]]></title>
    <link href="http://yeziahehe.com/2017/07/07/Haptic_feedback_with_uifeedbackgenerator/"/>
    <id>http://yeziahehe.com/2017/07/07/Haptic_feedback_with_uifeedbackgenerator/</id>
    <published>2017-07-07T07:47:29.000Z</published>
    <updated>2017-07-07T16:45:17.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p><strong>Tips：触觉反馈的特性从 iOS 10 开始支持，并且需要iPhone 7 和 iPhone 7 Plus 内置的新 Taptic 引擎支持这些应用程序接口（API）。</strong></p>
<p>最近在使用饿了么定外卖的时候，偶然感觉到饿了么下拉刷新有个震动。起初我并不知道这个是触觉反馈，后来我发现包括调用 Apple Pay 支付的时候，成功和失败都回引起触觉反馈。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="http://7xkvt5.com1.z0.glb.clouddn.com/blog/system.jpg" alt=""></th>
<th style="text-align:center"><img src="http://7xkvt5.com1.z0.glb.clouddn.com/blog/ele.jpg" alt=""></th>
<th style="text-align:center"><img src="http://7xkvt5.com1.z0.glb.clouddn.com/blog/Apple_Pay.jpg" alt=""></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">系统触感强度设置</td>
<td style="text-align:center">饿了么刷新触觉反馈</td>
<td style="text-align:center">Apple Pay 支付成功和失败触觉反馈</td>
</tr>
</tbody>
</table>
<h1 id="u89E6_u89C9_u53CD_u9988"><a href="#u89E6_u89C9_u53CD_u9988" class="headerlink" title="触觉反馈"></a>触觉反馈</h1><p>iOS 10 引入了一种新的产生触觉反馈的方式，通过使用系统的预定义震动模式，让用户在进行操作时得到不同的震动反馈。这个功能有新增的 <code>UIFeedbackGenerator</code> 提供，根据官方的<a href="https://developer.apple.com/documentation/uikit/uifeedbackgenerator" target="_blank" rel="external">文档</a>：</p>
<blockquote>
<p>The abstract superclass for all feedback generators.</p>
</blockquote>
<p>该类为一个抽象类，提供三个子类 <code>UIImpactFeedbackGenerator</code>、<code>UISelectionFeedbackGenerator</code> 和 <code>UINotificationFeedbackGenerator</code>。</p>
<h2 id="UIImpactFeedbackGenerator"><a href="#UIImpactFeedbackGenerator" class="headerlink" title="UIImpactFeedbackGenerator"></a>UIImpactFeedbackGenerator</h2><blockquote>
<p>Use impact feedback generators to indicate that an impact has occurred.</p>
</blockquote>
<p>预示着按压发生了。比如系统触感强度设置就是为了在你按 Home 键的时候给你一反馈，实际上 iPhone 7 的 Home 键并可以按动。</p>
<p><code>UIImpactFeedbackStyle</code> 一共是三种：<code>.light</code>、<code>.medium</code>、<code>heavy</code>，分别对应了系统触感强度里面的 1、2、3。</p>
<h2 id="UISelectionFeedbackGenerator"><a href="#UISelectionFeedbackGenerator" class="headerlink" title="UISelectionFeedbackGenerator"></a>UISelectionFeedbackGenerator</h2><blockquote>
<p>Use selection feedback generators to indicate a change in selection.</p>
</blockquote>
<p>预示着选择的变化。比如饿了么的刷新触觉反馈，这里普及一下，这种刷新反馈是因为饿了么使用的系统的 <code>UIRefreshControl</code> 方法去做的下拉刷新，而系统为这种方法下拉的 <code>offsetY</code> 做了触觉反馈的适配。</p>
<h2 id="UINotificationFeedbackGenerator"><a href="#UINotificationFeedbackGenerator" class="headerlink" title="UINotificationFeedbackGenerator"></a>UINotificationFeedbackGenerator</h2><blockquote>
<p>Use notification feedback generators to indicate successes, failures, and warnings.</p>
</blockquote>
<p>预示着成功、失败和警告。比如 Apple_Pay 支付成功和失败的反馈，这里比较了下三种情况的反馈，应该是在力度上面有所差别。和 Impact 的差别在于，这里的触觉反馈类似左右摇动两下。</p>
<p><code>UINotificationFeedbackType</code> 同样也是三种：<code>.success</code>、<code>.warning</code>、<code>error</code>。</p>
<h1 id="u7528_u6CD5"><a href="#u7528_u6CD5" class="headerlink" title="用法"></a>用法</h1><p>最后讲一下用法，掘金的翻译计划 <a href="https://juejin.im/entry/5810433ac4c9710058a74100" target="_blank" rel="external">[译] 如何使用 UIFeedbackGenerator 让应用支持 iOS 10 的触觉反馈</a> 中，给出了一个 Demo。注意 Demo 中有个问题，<strong>addsubview 应该在添加约束之前，否则会引起崩溃。</strong></p>
<p>不过根据官方的文档,触发触觉效果之前，在你的生成器 (generator) 内调用 prepare() 方法，这样可以有效的减少延迟。可以参考官方文档中的代码，也可以参考如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> feedbackGenerator : <span class="type">UIImpactFeedbackGenerator</span>? = <span class="type">UIImpactFeedbackGenerator</span>(style: .heavy)</div><div class="line"></div><div class="line"><span class="keyword">deinit</span> &#123;</div><div class="line">    feedbackGenerator = <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidLoad()</div><div class="line">    feedbackGenerator?.prepare()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">getNewGank</span><span class="params">(<span class="number">_</span> sender: UIBarButtonItem)</span></span> &#123;</div><div class="line">    feedbackGenerator?.impactOccurred()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt=""><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2017/07/07/Haptic_feedback_with_uifeedbackgenerator/">http://yeziahehe.com/2017/07/07/Haptic_feedback_with_uifeedbackgenerator/</a></blockquote>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p><strong>Tips：触觉反馈的特性从 iO]]>
    </summary>
    
      <category term="iOS" scheme="http://yeziahehe.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://yeziahehe.com/tags/Swift/"/>
    
      <category term="技术" scheme="http://yeziahehe.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UITableViewCell 高度自适应牵扯出的若干问题]]></title>
    <link href="http://yeziahehe.com/2017/06/30/UITableViewCell_Self_Sizing/"/>
    <id>http://yeziahehe.com/2017/06/30/UITableViewCell_Self_Sizing/</id>
    <published>2017-06-30T02:43:19.000Z</published>
    <updated>2017-07-01T04:47:28.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p>阔别了一年写代码的感觉，工作以来一直从事产品经理的相关工作，最近开始寻找当年写代码的感觉。碰巧上来被一个原以为很简单的问题困扰了很久，下面给大家详细讲讲使用 Self-Sizing Cell 做高度自适应遇到的若干坑。</p>
<h1 id="Self-Sizing_Cell"><a href="#Self-Sizing_Cell" class="headerlink" title="Self-Sizing Cell"></a>Self-Sizing Cell</h1><p>Self-Sizing 是 Apple 在 iOS 8 之后推出的新技术，是用于在调整系统字体大小后，控件元素中的文字能跟自动使用布局，下图所示的就是配合 Self-Sizing 推出的系统修改字体。</p>
<p><img src="http://7xkvt5.com1.z0.glb.clouddn.com/blog/font_size.jpeg?imageView2/2/h/750" alt="文字大小"></p>
<p>在 iOS8 以前，决定 tableviewcell 的高度的都是 <code>tableView:heightForRowAt:</code>，在该方法中手动计算 cell 的高度。iOS 8 之后，Apple 推出了新技术 Self-Sizing，通过 Working with Self-Sizing Tableview cells，将 cell 和 Self-Sizing 进行配合使用后这个协议函数就不用管了，高度系统会自动进行计算。具体的实现方式如下：</p>
<h2 id="Step_One"><a href="#Step_One" class="headerlink" title="Step One"></a>Step One</h2><p>通过 StoryBoard 新建 Custom TableView Cell，并且把要自适应文本高度的 UILabel 添加上约束。约束的原则如果上下左右没有其他元素，直接和 SuperView 做相对约束，如果有其他元素，则其他元素需要布局确定，UILabel 做相对约束。注意很重要的一点，<strong>最后 UILabel 的约束最后对宽和高都没有做约束，只有上下左右四边的约束看</strong>，这样的 Cell 才可以进行高度自适应。</p>
<p><img src="http://7xkvt5.com1.z0.glb.clouddn.com/blog/Storyboard_AutoLayout.png" alt="设置 StoryBoard"></p>
<h2 id="Step_Two"><a href="#Step_Two" class="headerlink" title="Step Two"></a>Step Two</h2><p>在代码中添加两个方法，接下来加载出数据的时候就可以自动计算高度。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidLoad()</div><div class="line">    tableView.rowHeight = <span class="type">UITableViewAutomaticDimension</span></div><div class="line">    tableView.estimatedRowHeight = <span class="number">100</span><span class="comment">//估算高度尽可能的接近 cell 的高度</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="u7531_u6B64_u5F15_u53D1_u7684_u95EE_u9898"><a href="#u7531_u6B64_u5F15_u53D1_u7684_u95EE_u9898" class="headerlink" title="由此引发的问题"></a>由此引发的问题</h1><h2 id="1-willDisplayCell_3AforRowAtIndexPath_3A_and_cellForRowAtIndexPath_3A"><a href="#1-willDisplayCell_3AforRowAtIndexPath_3A_and_cellForRowAtIndexPath_3A" class="headerlink" title="1.willDisplayCell:forRowAtIndexPath: and cellForRowAtIndexPath:"></a>1.willDisplayCell:forRowAtIndexPath: and cellForRowAtIndexPath:</h2><p>在关于优化 UITableView 的文章中，提到了一个优化方案。</p>
<blockquote>
<p>我们经常在注意cellForRowAtIndexPath：中为每一个cell绑定数据，实际上在调用cellForRowAtIndexPath：的时候cell还没有被显示出来，为了提高效率我们应该把数据绑定的操作放在cell显示出来后再执行，可以在tableView：willDisplayCell：forRowAtIndexPath：方法中绑定数据。</p>
</blockquote>
<p>我刚刚开始对这个观点是认可，并且也确实这么做了，于是代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</div><div class="line">    <span class="keyword">let</span> cell: <span class="type">CustomCell</span> = tableView.dequeueReusableCell()</div><div class="line">    <span class="keyword">return</span> cell</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath)</span></span> &#123;</div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> cell = cell <span class="keyword">as</span>? <span class="type">CustomCell</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    cell.titleLabel.text = <span class="type">Json</span>.desc</div><div class="line">    <span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在执行上述代码之后，我发现了一个问题，UITableViewCell 的高度加载并不正确，是估算的高度，并不是计算的高度，如下图。</p>
<p><img src="http://7xkvt5.com1.z0.glb.clouddn.com/blog/cell_height.png?imageView2/2/h/750" alt="未计算出正确高度"></p>
<p>滑动之后新加载的 TableViewCell 高度为计算出来且正确。（继承 UITableViewViewController 即 Delegate and DataSource 方法为 override 可以滑动加载正确高度；而继承自 UIViewController 即 Delegate and DataSource 方法是 extension 滑动也不可以加载正确高度。<strong>注意，后面的继承未写 Demo 论证，若有不对请指出</strong>）</p>
<p>从上面的问题里面，我开始寻找两个方法的作用和遇到类似问题的解答方式，我在 Stack Overflow 上面找到了类似的问题 <strong><a href="https://stackoverflow.com/questions/42649231/uitableview-cellforrowat-vs-willdisplay/42649420#42649420" target="_blank" rel="external">UITableView cellForRowAt vs willDisplay</a></strong>。上面阐述的解释是高度的计算是在 <code>cellForRowAtIndexPath:</code> 之后，在 <code>willDisplayCell:forRowAtIndexPath:</code> 之前，所以需要再次调用 <code>reloadData</code> 方法。</p>
<blockquote>
<p>My understanding that at height is calculating after cellForRowAt but before willDisplay, so when I’m mapping in willDisplay height is already set for my cell and I need to reload it again (which is not good).</p>
</blockquote>
<p>这个结论我是认同，所以解决这个问题的办法就有两个方案。</p>
<ul>
<li>将数据绑定从 <code>willDisplayCell:forRowAtIndexPath:</code> 中移到 <code>cellForRowAtIndexPath:</code> 中；</li>
<li>再次调用 <code>reloadData</code> 放大，代码如下：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.tableView.reloadData()</div><div class="line"><span class="comment">// 3 new lines of codes to force size adjustment</span></div><div class="line"><span class="keyword">self</span>.tableView.setNeedsLayout()</div><div class="line"><span class="keyword">self</span>.tableView.layoutIfNeeded()</div><div class="line"><span class="keyword">self</span>.tableView.reloadData()</div></pre></td></tr></table></figure>
<p>上述两个方案，第二个方案是强制高度自适应，具体可以参考这边文章 <a href="http://jianjye.com/swift-resize-uitextview-tableviewcell-correctly-json-fetch/#comment-512" target="_blank" rel="external">Swift: How to Resize UITextView + TableViewCell Correctly After JSON Fetch</a>，但是这个方法显得很臃肿，也并不能算是优雅的解决方案。于是我看到第一个方案时产生了疑问：</p>
<p><strong>【为了提高效率我们应该把数据绑定的操作放在 cell 显示出来后再执行】</strong> 这个观点是正确的吗？</p>
<h2 id="u6570_u636E_u7ED1_u5B9A_u5E94_u8BE5_u653E_u5728_u54EA_u513F_uFF1F"><a href="#u6570_u636E_u7ED1_u5B9A_u5E94_u8BE5_u653E_u5728_u54EA_u513F_uFF1F" class="headerlink" title="数据绑定应该放在哪儿？"></a>数据绑定应该放在哪儿？</h2><p>我们首先看下苹果官方文档关于 <code>willDisplayCell:forRowAtIndexPath:</code> 的解释，该方法应该是修改状态类型基本属性，比如选择状态、背景颜色等等：</p>
<blockquote>
<p>This method gives the delegate a chance to override state-based properties set earlier by the table view, such as selection and background color.</p>
</blockquote>
<p>官方文档关于 <code>cellForRowAtIndexPath:</code> 的解释，该方法应该是讲数据源插入到 UITableView 正确的位置：</p>
<blockquote>
<p>Asks the data source for a cell to insert in a particular location of the table view.</p>
</blockquote>
<p>在此同时，我看到了一篇详细的文章 <a href="https://tech.zalando.com/blog/proper-use-of-cellforrowatindexpath-and-willdisplaycell/" target="_blank" rel="external">Proper Use of CellForRowAtIndexPath and WillDisplayCell</a>，文章中指出：</p>
<blockquote>
<p>Orlov’s article is an important guide for advanced programming. However, he is lacking proof for the tableView delegate method willDisplayCell:forRowAtIndexPath:. This has been something that has bothered me for a while, as so many people quoted the paragraph about willDisplayCell from the article.</p>
</blockquote>
<p>很重要的一句话，<strong>并没有任何理由能够支持他说的绑定数据在 willDisplayCell 能够提高 UITableView 的性能</strong>。并且他做了实验，发现 <code>layoutSubviews</code> 是在 <code>willDisplayCell:forRowAtIndexPath:</code> 和 <code>cellForRowAtIndexPath:</code> 两个方法之后，也就是说不管你在哪个方法中去绑定数据，cell 被 layouted 总在他们之后，那么在这之前就不会 Rendering，也就不存在绑定数据在 <code>cellForRowAtIndexPath:</code> 方法中会影响性能。</p>
<p>那么，这个优化方案并没有任何理论根据，于是忘了吧，<del>我们经常在注意cellForRowAtIndexPath：中为每一个cell绑定数据，实际上在调用cellForRowAtIndexPath：的时候cell还没有被显示出来，为了提高效率我们应该把数据绑定的操作放在cell显示出来后再执行，可以在tableView：willDisplayCell：forRowAtIndexPath：方法中绑定数据。</del></p>
<p><strong>注意，关于 Orlov’s article 虽然提升这一点没有被佐证，但是其他的优化方案非常值得学习，</strong> 我这边附上链接，有兴趣可以学习！注意使用梯子~~ <a href="https://medium.com/ios-os-x-development/perfect-smooth-scrolling-in-uitableviews-fd609d5275a5" target="_blank" rel="external">文章：perfect smooth scrolling in uitableviews</a></p>
<h2 id="u81EA_u52A8_u8BA1_u7B97_u52A0_u8F7D_u4E86_u51E0_u6B21_uFF1F"><a href="#u81EA_u52A8_u8BA1_u7B97_u52A0_u8F7D_u4E86_u51E0_u6B21_uFF1F" class="headerlink" title="自动计算加载了几次？"></a>自动计算加载了几次？</h2><p>本来到这边应该结束文章，但是在探讨上述问题的时候，发现了很奇怪的一件事情。如果你在 UITableView Delegate 或者 DataSource 方法中打印一下，会发现每个方法中的打印出现了2遍。</p>
<p><img src="http://7xkvt5.com1.z0.glb.clouddn.com/blog/print_twice.png" alt="打印两边"></p>
<p>于是，我参考了两篇文章：<a href="https://stackoverflow.com/questions/41318864/scrollviewdidscroll-is-called-twice-after-set-table-offset" target="_blank" rel="external">scrollViewDidScroll is called “twice” after set table offset</a>、<a href="https://discussions.apple.com/thread/7111979?start=0&amp;tstart=0" target="_blank" rel="external">heightForRowAtIndexPath called twice in iOS 8 but one time in iOS 7</a></p>
<p><code>tableView.estimatedRowHeight = 100</code> 这句话是引起 UITableView 加载两次的原因，注释掉这句话后，发现打印一次。我并没有找到合理的理由去解释这个原因，网上部分猜测是 Apple 官方的 Bug，如果大家对这个问题有更好的解释，不妨联系我，我会第一时间更新。</p>
<blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt=""><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2017/06/30/UITableViewCell_Self_Sizing/">http://yeziahehe.com/2017/06/30/UITableViewCell_Self_Sizing/</a></blockquote>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p>阔别了一年写代码的感觉，工作以来一直从事产品经理]]>
    </summary>
    
      <category term="iOS" scheme="http://yeziahehe.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://yeziahehe.com/tags/Swift/"/>
    
      <category term="技术" scheme="http://yeziahehe.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2016-10 读书小记]]></title>
    <link href="http://yeziahehe.com/2016/10/30/October_Reading/"/>
    <id>http://yeziahehe.com/2016/10/30/October_Reading/</id>
    <published>2016-10-30T14:44:55.000Z</published>
    <updated>2017-06-30T02:43:55.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5341_u6708_u8BFB_u4E66_u5C0F_u8BB0"><a href="#u5341_u6708_u8BFB_u4E66_u5C0F_u8BB0" class="headerlink" title="十月读书小记"></a>十月读书小记</h1><ul>
<li><strong>《皮囊》</strong>：一个很长的故事，陆陆续续的看了很久，已经不是记忆很深刻了。叙事的风格非常的慢，但是却慢慢的用细腻的感情在浸入你的心灵，很好的一本书。最打动人心的东西，永远是亲情。</li>
<li><strong>《白鹿原》</strong>：忽然间很想看的，很早看过电影。书的内容远远比电影来的要丰富的多，年代感非常强，人物性格很鲜明，不同的人，不同的选择，以及在时代背景下人人都要妥协。看完更多的是对人性有了认识和思考。</li>
<li><strong>《嫌疑人X的献身》</strong>：东野圭吾最经典的小说，一直到最后我才知道这个局的谜底，很震撼，很意外。强烈建议大家读一读。</li>
<li><strong>《从你的全世界路过》</strong>：张嘉佳，因为电影火了，就顺便看了看。就如同张嘉佳自己说的那样，这本书里的很多故事被影视圈的朋友们排成电影。书中的故事都是亲情、友情、爱情。我被其中几篇文章感动到了，曾经一度泪流满面。很不错的读物，有时间看看，你可能会对除了事业以外的很多东西有更多不一样的看法。</li>
<li><strong>《惊奇物语》</strong>：消磨时间的书。</li>
</ul>
<h1 id="u8BF4_u4E24_u53E5"><a href="#u8BF4_u4E24_u53E5" class="headerlink" title="说两句"></a>说两句</h1><p>这个月的书，明显鸡汤少了很多，回过头来看看，才发现，其实啊，人的这一生，年轻的时候，把一切都看的太重要，工作、婚姻、生活、压力，这些事情让我们在青年、中年的时候会喘不过气来，会没有时间去思考很多事情。人们总是说村里最有智慧的是年长的人，其实因为他们放下来很多东西，看到了更多应该去看到的东西。人是社会里面的连接体，会与周遭的一切有着各种各样的联系，有些值得去维系，有些值得去放弃。人这一生麻烦的事情会有很多，遇到事情千万别逃避，因为最后总要解决，不管过程怎么样，勇于去面对，才是面对人生，面对明天最正确的姿态。</p>
<blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt=""><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2016/10/30/October_Reading/">http://yeziahehe.com/2016/10/30/October_Reading/</a></blockquote>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5341_u6708_u8BFB_u4E66_u5C0F_u8BB0"><a href="#u5341_u6708_u8BFB_u4E66_u5C0F_u8BB0" class="headerlink" title="十月读书小记"></a>十月读书小记</h1]]>
    </summary>
    
      <category term="读书" scheme="http://yeziahehe.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="读书" scheme="http://yeziahehe.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2016-09 读书小记]]></title>
    <link href="http://yeziahehe.com/2016/09/12/September_Reading/"/>
    <id>http://yeziahehe.com/2016/09/12/September_Reading/</id>
    <published>2016-09-12T02:41:46.000Z</published>
    <updated>2016-09-30T06:02:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u4E5D_u6708_u8BFB_u4E66_u5C0F_u8BB0"><a href="#u4E5D_u6708_u8BFB_u4E66_u5C0F_u8BB0" class="headerlink" title="九月读书小记"></a>九月读书小记</h1><p>上次给大家提到了 <strong>微信读书</strong>，真的是被深深的迷上了这个软件，这个月阅读电子书的数量和时间非常的多。</p>
<p>9月整理了下书，这个月读的书按照先后顺序如下：</p>
<ul>
<li><strong>《解忧杂货店》</strong>：最近非常火的一本书，作者是<a href="http://baike.baidu.com/link?url=CZIw00CRktQgrKveTCryvFh_iNZnxhzuq6hR4b-OUSajpOzk47XfY-KAoRzTyW33AMh9sY6ln4Y55TT_o7MCbK" target="_blank" rel="external">东吾圭野</a>，日本非常著名的推理小说家，所创作的书逻辑滴水不漏，架构匪夷所思。我看了解忧杂货店，非常大的感受就是，<strong>如果自己不积极认真的生活，不管得到怎么样的回答都没有用。别人的回答只是坚定自己内心深处的想法，让自己更有勇气去实现自己内心的声音。</strong></li>
<li><strong>《MacTalk·人生元编程》</strong>：池老师，现在在锤子，把他博客里面的文章整理成的书，内容比较杂，对自己人生观和职业观影响会多点，可以花几个小时翻一翻。</li>
<li><strong>《过得刚好》</strong>：郭德纲的自传，算是现在时代下的枭雄。作为相声人，这一辈子也算是比较传奇的，早期为了生计，后期为了相声的传承。经历过大起大落，也同样经历过大是大非，心态、心境确实不是一般人能达到的。他的经历不可复制，没有相似性，正如世间仅此一个郭德纲，他的经历却又符合历史的发展，相声成就了老郭，同样老郭也成就了相声。</li>
<li><strong>《随遇而安》</strong>：孟非的自传，正如他所说平淡的一生。孟非真的是人生的各种选择和运气，让他到了现在的成就。如果当年就那样在印刷厂，估计现在还是阶级的最底层。不可否认，他是有内涵，在我心里面，他算作最有内涵的人第二名。他能平淡的把批判的话讲出来，不那么生硬，很自然，很在理。看孟非，我始终觉得是个挺简单的人。</li>
<li><strong>《天才在左，疯子在右》</strong>：这本书吧，我看到陈乔恩在《我们来了》里面推荐过。讲真的，从早开始看的时候的惊悚，到后来我慢慢的开始思考，再到最后对世界观和别人眼中世界的尊重。我能理解，自然中总会有很多你不能用科学去解释的事情，一是因为科技说明远没有那么发达，更重要的是也许这真的就是自然奇妙的地方。我看的感受，就是不管别人眼中的世界观和价值观是怎么样，你可以不理解，但是不能不尊重。我看完这本书，就有种想去研究精神学和物理学的冲动，不得不说，其实人啊，真的很渺小。从宏观的角度去看，我们现在困扰、纠结的事情真的在时间面前犹如蝼蚁一般，所以积极的去面对这个世界，去拥抱美好，去敬畏未知，去积极的生活下去，也许是作者最想告诉我们的。</li>
<li><strong>《人人都是产品经理》</strong>：产品经理入门比较经典的书籍，很快的时间看完了，主要还是要悟出自己的思路出来。</li>
</ul>
<h1 id="u8BF4_u4E24_u53E5"><a href="#u8BF4_u4E24_u53E5" class="headerlink" title="说两句"></a>说两句</h1><p>我特别有感触的一句话，<strong>【成功：一分天赋、三分努力、六分运气】</strong>。也是从我看到老郭和老孟的自传想说的，选择比努力更重要。一个人在世间，从他离开校园的那一刻开始，平台优势、起点优势都不复存在了。你会发现，从进入社会的那刻，似乎大家都开始感觉生活很坚信，你总会经过迷茫的时间，区别在于什么时候你能从那其中跳出来，宏观的去看自己的发展。选择就是那六分运气的基础。没有最好的选择，没有最坏的选择，只有最适合自己的基础，给自己定个小目标吧，纯粹的目标，不涉及到选择。比如我要在几年拿个什么证书，慢慢的去投资自己，知道自己最后要走到哪里。路是什么样，其实不重要，选择你喜欢，坚定的走下去吧。</p>
<blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt=""><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2016/09/12/September_Reading/">http://yeziahehe.com/2016/09/12/September_Reading/</a></blockquote>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u4E5D_u6708_u8BFB_u4E66_u5C0F_u8BB0"><a href="#u4E5D_u6708_u8BFB_u4E66_u5C0F_u8BB0" class="headerlink" title="九月读书小记"></a>九月读书小记</h1]]>
    </summary>
    
      <category term="读书" scheme="http://yeziahehe.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="读书" scheme="http://yeziahehe.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2016-08 读书小记]]></title>
    <link href="http://yeziahehe.com/2016/08/31/August_Reading/"/>
    <id>http://yeziahehe.com/2016/08/31/August_Reading/</id>
    <published>2016-08-31T12:04:21.000Z</published>
    <updated>2016-09-02T02:55:07.000Z</updated>
    <content type="html"><![CDATA[<p>这个月开始，公司的小伙伴都开始大规模的买书，倒是让我想起来上半年买的很多书，还一直都没有读，以后应该每个月都会整理 <strong>读书小记</strong>，多读书。由于8月中旬才开始读书，所以这个月读书非常较少。</p>
<p>8月整理了下书，这个月读的书按照先后顺序如下：</p>
<ul>
<li><strong>《How Google Works》</strong>：一本讲创业的书，书中对于企业的管理有着值得学习推敲的地方，不日我会写篇读书笔记，将所感记录下来。</li>
<li><strong>《人类简史》</strong>：以色列一位年轻的历史学家写的人来发展史，角度非常宏观，刚刚翻看了一小部分，等看完再做评论。</li>
<li><strong>《富爸爸 穷爸爸》</strong>：如果让我来评选下，我会说在这个年龄段和状态下遇到这本书，是我的幸运。我从书中收获非常多，这本书改变了我的金钱观，我觉得也会改变我的人生轨迹，让我反思了很多。我会等到看第三遍的时候认真的写一篇书评。</li>
</ul>
<p><strong>Tips</strong><br>最近发现了 <strong>微信读书</strong>，在iPad上面体验非常好，建议大家可以不要全部买纸质书，想买书之前先去微信翻一下，觉得可以精读，再来本纸质书、泡杯咖啡，享受人生吧！</p>
<blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt=""><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2016/08/31/August_Reading/">http://yeziahehe.com/2016/08/31/August_Reading/</a></blockquote>]]></content>
    <summary type="html">
    <![CDATA[<p>这个月开始，公司的小伙伴都开始大规模的买书，倒是让我想起来上半年买的很多书，还一直都没有读，以后应该每个月都会整理 <strong>读书小记</strong>，多读书。由于8月中旬才开始读书，所以这个月读书非常较少。</p>
<p>8月整理了下书，这个月读的书按照先后顺序如]]>
    </summary>
    
      <category term="读书" scheme="http://yeziahehe.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="读书" scheme="http://yeziahehe.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构学习（一）--栈]]></title>
    <link href="http://yeziahehe.com/2016/08/16/Structure_stack/"/>
    <id>http://yeziahehe.com/2016/08/16/Structure_stack/</id>
    <published>2016-08-16T09:41:32.000Z</published>
    <updated>2016-08-17T03:15:01.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u6808"><a href="#u6808" class="headerlink" title="栈"></a>栈</h1><p>栈是所有数据结构中最简单但却是最重要的一种，栈出现的情况在对内含反转数据的应用非常适合。栈是属于 <strong>后进先出 - Last In, First Out（LIFO）</strong> ，最后压入栈中的项总是最先从栈中弹出的项，生活中举个例子说明下，装薯片的时候按顺序装入罐子中，但是吃薯片的时候就要从开口处把最后一个装入的薯片先吃掉。</p>
<p>栈是一种形式的表，属于表类型中的受限表，即插入和删除只发生在一端。在栈当中我们把这端成为栈顶（top）。当我们对栈顶进行插入操作时，即向栈中增加一项时，称之为入栈（push）；对栈进行删除操作时，即从栈中删除一项时，称之为出栈（pop）。</p>
<h1 id="u6838_u5FC3_u65B9_u6CD5"><a href="#u6838_u5FC3_u65B9_u6CD5" class="headerlink" title="核心方法"></a>核心方法</h1><p>对于栈来说，主要的核心方法就是入栈和出栈两个方法，向栈顶入栈一个”i”的字符串：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stack.push(<span class="string">"i"</span>)</div></pre></td></tr></table></figure></p>
<p>目前栈中间的元素为[“i”]，从栈里面出栈当前的元素：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stack.pop()</div></pre></td></tr></table></figure></p>
<p>这样返回了元素”i”，并且当前栈为空。继续出栈会导致返回nil，通常在实际应用中这里会做错误处理，“栈下溢（stack underflow）”。</p>
<h1 id="u6E90_u4EE3_u7801"><a href="#u6E90_u4EE3_u7801" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Stack.swift</span></div><div class="line"><span class="comment">//  Stack</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Created by 叶帆 on 16/8/15.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> array = <span class="type">Array</span>&lt;<span class="type">Element</span>&gt;()</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     获取当前栈的长度</div><div class="line">     - returns: 返回栈的长度，如果Stack为空，则值为0</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> array.<span class="built_in">count</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     判断是否为空</div><div class="line">     - returns: 如果Stack为空，则值为true，否则值为false</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">        <span class="keyword">return</span> array.isEmpty</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     获取栈顶元素的值</div><div class="line">     - returns: 栈顶元素的值，如果为空返回nil</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">top</span><span class="params">()</span></span> -&gt; <span class="type">Element</span>? &#123;</div><div class="line">        <span class="keyword">return</span> array.last</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     向栈顶插入一个元素</div><div class="line">     - parameter element: 需要插入的值</div><div class="line">     - 时间复杂度: O(1)</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(element: Element)</span></span> &#123;</div><div class="line">        array.append(element)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     删除栈顶元素</div><div class="line">     - returns: 返回删除栈顶元素的值，如果为空返回nil</div><div class="line">     - 时间复杂度: O(1)</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">Element</span>? &#123;</div><div class="line">        <span class="keyword">return</span> array.popLast()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Stack</span>: <span class="title">SequenceType</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">()</span></span> -&gt; <span class="type">AnyGenerator</span>&lt;<span class="type">Element</span>&gt; &#123;</div><div class="line">        <span class="keyword">var</span> curr = <span class="keyword">self</span></div><div class="line">        <span class="keyword">return</span> <span class="type">AnyGenerator</span> &#123;</div><div class="line">            <span class="number">_</span> -&gt; <span class="type">Element</span>? <span class="keyword">in</span></div><div class="line">            <span class="keyword">return</span> curr.pop()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="u5E94_u7528_u573A_u666F"><a href="#u5E94_u7528_u573A_u666F" class="headerlink" title="应用场景"></a>应用场景</h1><p>栈的强项是处理反转的能力，所以实际的应用场景都是和此相关的。</p>
<h2 id="u56DE_u6587_u5B57_u7B26_u4E32"><a href="#u56DE_u6587_u5B57_u7B26_u4E32" class="headerlink" title="回文字符串"></a>回文字符串</h2><p>所谓的回文字符串就是指那些正读和反读均相同的字符系列，如“席主席”，“aha”均是回文，通过栈这种数据结构可以很容易判断一个字符串是否为回文。</p>
<p>大概的思路就是找到中间的值，把中间值以前的放入栈中，然后一个个出栈，并且在出栈的同时和中间值以后的值进行比对。如果top为空的时候就说明符合回文的规则。</p>
<h2 id="u9006_u6CE2_u5170_u8BA1_u7B97_u5668"><a href="#u9006_u6CE2_u5170_u8BA1_u7B97_u5668" class="headerlink" title="逆波兰计算器"></a>逆波兰计算器</h2><p>所谓的逆波兰计算器指的就是在这样的计算器中，操作数（通常是数字）在操作被指定前输入，操作数放入栈中。当操作执行时，操作数从栈中弹出并且把操作结果入栈。</p>
<h2 id="u62EC_u53F7_u7684_u5339_u914D"><a href="#u62EC_u53F7_u7684_u5339_u914D" class="headerlink" title="括号的匹配"></a>括号的匹配</h2><p>在程序中，通常会对<code>{}</code>、<code>[]</code>、<code>()</code>、<code>&lt;&gt;</code>来进行括号的匹配。</p>
<blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt=""><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2016/08/16/Structure_stack/">http://yeziahehe.com/2016/08/16/Structure_stack/</a></blockquote>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u6808"><a href="#u6808" class="headerlink" title="栈"></a>栈</h1><p>栈是所有数据结构中最简单但却是最重要的一种，栈出现的情况在对内含反转数据的应用非常适合。栈是属于 <strong>后进先出 - La]]>
    </summary>
    
      <category term="数据结构" scheme="http://yeziahehe.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="栈" scheme="http://yeziahehe.com/tags/%E6%A0%88/"/>
    
      <category term="算法" scheme="http://yeziahehe.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://yeziahehe.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 持续集成--Travis CI + Fir.im自动编译发布]]></title>
    <link href="http://yeziahehe.com/2016/08/07/use_travis_ci_for_ios_project/"/>
    <id>http://yeziahehe.com/2016/08/07/use_travis_ci_for_ios_project/</id>
    <published>2016-08-07T12:12:14.000Z</published>
    <updated>2016-08-08T11:45:26.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p>持续集成一直是现在非常热门的话题，通过持续集成可以自动编译项目，并且配合单元测试可以实现持续集成+自动化测试。我在结合CI的基础上，通过fir-cli的发布命令，完成了持续集成+自动部署。这样能够很好的减少测试、发包等一系列重复的工作，极大的提高了效率。</p>
<p>持续集成的优点：</p>
<ul>
<li>“快速失败”，在对产品没有风险的情况下进行测试，并快速响应；</li>
<li>最大限度地减少风险，降低修复错误代码的成本；</li>
<li>将重复性的手工流程自动化，让工程师更加专注于代码；</li>
<li>保持频繁部署，快速生成可部署的软件；</li>
<li>提高项目的能见度，方便团队成员了解项目的进度和成熟度；</li>
<li>增强开发人员对软件产品的信心，帮助建立更好的工程师文化。</li>
</ul>
<p>这边推荐一篇文章给大家，<a href="http://blog.flow.ci/cicd_difference/" target="_blank" rel="external">谈谈持续集成，持续交付，持续部署之间的区别</a>。</p>
<h1 id="Travis_CI"><a href="#Travis_CI" class="headerlink" title="Travis CI"></a>Travis CI</h1><p>如果你的项目是托管在 Github 上，那么 <a href="https://travis-ci.org/" target="_blank" rel="external">Travis CI</a> 是做持续集成非常好的选择。在 Ruby 的世界中，Travis CI 已久负盛名，从 2013 年 4 月起，Travis 也开始支持 iOS 和 Mac 平台。</p>
<p>本文主要来一步步讲解在项目中集成 Travis CI，不仅包括项目的编译和单元测试的运行，还包括将应用部署到 Fir.im 的测试设备上。</p>
<h1 id="u4E0EGithub_u96C6_u6210"><a href="#u4E0EGithub_u96C6_u6210" class="headerlink" title="与Github集成"></a>与Github集成</h1><p>首先需要到 <a href="https://travis-ci.org/" target="_blank" rel="external">Travis CI</a> 官网上，使用自己的 Github 进行登录。登录后新建与 Github Repo 的关联，如下图所示：<br><img src="http://7xkvt5.com1.z0.glb.clouddn.com/blog/new_repo" alt="new repo"></p>
<p>选择需要管理的 Repo，把前面的按钮置为绿色就关联 OK，这样 Travis CI 这边的配置就完成了：<br><img src="http://7xkvt5.com1.z0.glb.clouddn.com/blog/connect_repo.png" alt="connect repo"></p>
<p>然后去 Github 关联的 Repo 中，找到 Settings - Webhooks&amp;Services 中添加 Webhook 即可，不需要填信息，直接 test 就能通过，如下图所示：<br><img src="http://7xkvt5.com1.z0.glb.clouddn.com/blog/github_webhook.png" alt="Github Webhook"></p>
<p>按照上述步骤，就成功的将 Travis CI 和 Github 关联起来了。</p>
<h1 id="u914D_u7F6ETravis_CI"><a href="#u914D_u7F6ETravis_CI" class="headerlink" title="配置Travis CI"></a>配置Travis CI</h1><p>Travis CI 通过配置文件 <strong>.travis.yml</strong> 来工作，文件存放在项目的根目录下，接下里我们就来配置这个文件。</p>
<h2 id="u57FA_u7840_u914D_u7F6E"><a href="#u57FA_u7840_u914D_u7F6E" class="headerlink" title="基础配置"></a>基础配置</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">language:</span> objective-c</div></pre></td></tr></table></figure>
<p><strong>虽然我们是 Swift 项目，但是在 Travis CI 支持的语言库里面仅支持 Objective-C，不过 iOS 项目不管哪种语言使用这个配置都可以进行部署。</strong></p>
<p>Travis 编译器运行在虚拟机环境下。该编译器已经利用 Ruby，Homebrew，CocoaPods，xctool 和一些默认的编译脚本进行过预配置。上述的配置项已经足够编译你的项目了。<br>预装的编译脚本会分析你的 Xcode 项目，并对每个 target 进行编译。如果所有文件都没有编译错误，并且测试也没有被打断，那么项目就编译成功了。现在可以将相关改动 Push 到 GitHub 中看看能否成功编译。</p>
<p>接下来，我们配置其他的 iOS 项目的基础配置。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">osx_image:</span> xcode7.<span class="number">3</span></div></pre></td></tr></table></figure></p>
<h2 id="u7F16_u8BD1_u547D_u4EE4"><a href="#u7F16_u8BD1_u547D_u4EE4" class="headerlink" title="编译命令"></a>编译命令</h2><p>接下来我们针对项目来使用自定义编译命令。iOS 项目编译使用 xcodebuild，Travis 提供了 xcodebuild 和 Xctool。xcodebuild 是Apple提供的命令，而 Xctool 是来自 Facebook 的命令行工具。推荐使用 Xctool，本篇教程也是使用 Xctool 来进行编译命令的编写。</p>
<p><a href="https://github.com/facebook/xctool" target="_blank" rel="external">Xctool</a> 是来自 Facebook 的命令行工具，它可以简化程序的编译和测试。它的彩色输出信息比 xcodebuild 更加简洁直观。同时还添加了对逻辑测试，应用测试的支持。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">language:</span> objective-c</div><div class="line"><span class="symbol">script:</span></div><div class="line">- xctool -workspace $APP_NAME.xcworkspace -scheme $APP_NAME -sdk iphoneos  -configuration Release OBJROOT=$PWD/build SYMROOT=$PWD/build ONLY_ACTIVE_ARCH=NO CODE_SIGN_IDENTITY=<span class="string">"$DEVELOPER_NAME"</span></div></pre></td></tr></table></figure></p>
<p>我这边给的配置命令，是直接最后能够发布到发包平台编译命令，通过 Travis 能自动将应用部署到我们的所有测试设备上。要使这个命令编译通过，我们需要进行如下的配置。</p>
<h2 id="u7A0B_u5E8F_u7B7E_u540D"><a href="#u7A0B_u5E8F_u7B7E_u540D" class="headerlink" title="程序签名"></a>程序签名</h2><p>为了在 Travis 中能给程序签名，我们需要准备好所有必须的证书和配置文件。就像每个 iOS 开发人员知道的那样，这可能是最困难、最容易出错的一步。</p>
<h3 id="iPhone__u53D1_u5E03_u8BC1_u4E66_+__u79C1_u94A5"><a href="#iPhone__u53D1_u5E03_u8BC1_u4E66_+__u79C1_u94A5" class="headerlink" title="iPhone 发布证书 + 私钥"></a>iPhone 发布证书 + 私钥</h3><p>我们可以在自己的开发环境将证书和私钥给导出来。如果还没有发布证书的话，先创建一个。登录<a href="https://developer.apple.com/account/overview.action" target="_blank" rel="external">苹果开发者账号</a>，按照步骤，创建一个新的生产环境证书 (Certificates &gt; Production &gt; Add &gt; App Store and Ad Hoc)。然后下载并安装证书。之后，可以在钥匙串中找到它。打开 Mac 中的 钥匙串 应用程序：<br><img src="http://7xkvt5.com1.z0.glb.clouddn.com/blog/Certificates.png" alt="Certificates"></p>
<p>右键单击证书，选择 Export… 将证书导出至 scripts/certs/dist.cer。然后导出私钥并保存至 scripts/certs/dist.p12。记得输入私钥的密码。<br><strong>备注：scripts 文件夹在项目根目录下。</strong></p>
<p>由于 Travis 需要知道私钥密码，因此我们要把这个密码存储在某个地方。当然，我们不希望以明文的形式存储。我们可以用 Travis 的安全环境变量。打开终端，并定位到包含 .travis.yml 文件所在目录。首先用下面的命令安装 Travis gem：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gem install travis</div></pre></td></tr></table></figure></p>
<p>之后，用下面的命令添加密钥密码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">travis encrypt <span class="string">"KEY_PASSWORD=&#123;password&#125;"</span> --add</div></pre></td></tr></table></figure></p>
<p>上面的命令会安装一个叫做 KEY_PASSWORD 的加密环境变量到 .travis.yml 配置文件中。这样就可以在被 Travis CI 执行的脚本中使用这个变量。</p>
<h3 id="iOS__u914D_u7F6E_u6587_u4EF6__28_u53D1_u5E03_29"><a href="#iOS__u914D_u7F6E_u6587_u4EF6__28_u53D1_u5E03_29" class="headerlink" title="iOS 配置文件 (发布)"></a>iOS 配置文件 (发布)</h3><p>如果还没有用于发布的配置文件，那么也创建一个新的。根据开发者账号类型，可以选择创建 <a href="https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/TestingYouriOSApp/TestingYouriOSApp.html" target="_blank" rel="external">Ad Hoc</a> 配置文件 (Provisioning Profiles &gt; Distribution &gt; Add &gt; Ad Hoc)。然后将其下载保存至 scripts/profile/ 目录。</p>
<p>由于 Travis 需要访问这个配置文件，所以我们需要将这个文件的名字存储为一个全局环境变量。并将其添加至 .travis.yml 文件的全局环境变量 section 中。例如，如果配置文件的名字是 <strong>YFSwiftFramework_Ad_Hoc.mobileprovision</strong>，那么按照如下进行添加：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">env:</span></div><div class="line">  <span class="symbol">global:</span></div><div class="line">  - APP_NAME=<span class="string">"YFSwiftFramework"</span></div><div class="line">  - <span class="string">'DEVELOPER_NAME="iPhone Distribution: &#123;your_name&#125;"'</span></div><div class="line">  - PROFILE_NAME=<span class="string">"YFSwiftFramework_Ad_Hoc"</span></div></pre></td></tr></table></figure></p>
<p>上面还声明了三个环境变量。</p>
<ul>
<li>APP_NAME 通常为项目默认 target 的名字。</li>
<li>DEVELOPER_NAME 是 Xcode 中，默认 target 里面 Build Settings 的 Code Signing Identity &gt; Release 对应的名字。</li>
<li>PROFILE_NAME 是配置文件的名字。</li>
</ul>
<h2 id="u52A0_u5BC6_u8BC1_u4E66_u548C_u914D_u7F6E_u6587_u4EF6"><a href="#u52A0_u5BC6_u8BC1_u4E66_u548C_u914D_u7F6E_u6587_u4EF6" class="headerlink" title="加密证书和配置文件"></a>加密证书和配置文件</h2><p>如果你的 GitHub 仓库是公开的，你可能希望对证书和配置文件 (里面包含了敏感数据) 进行加密。如果你用的是私有仓库或者不想加密的证书和配置文件的，可以跳至下一节。</p>
<p>首先，我们需要一个密码来对所有的文件进行加密。本文用密码 <strong>“123”</strong> 来进行举例。在Terminal中输入下面三个命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">openssl aes-256-cbc -k <span class="string">"123"</span> -<span class="keyword">in</span> scripts/profile/YFSwiftFramework_Ad_Hoc.mobileprovision -out scripts/profile/YFSwiftFramework_Ad_Hoc.mobileprovision.enc -a</div><div class="line">openssl aes-256-cbc -k <span class="string">"123"</span> -<span class="keyword">in</span> scripts/certs/dist.cer -out scripts/certs/dist.cer.enc -a</div><div class="line">openssl aes-256-cbc -k <span class="string">"123"</span> -<span class="keyword">in</span> scripts/certs/dist.p12 -out scripts/certs/dist.p12.enc -a</div></pre></td></tr></table></figure></p>
<p>通过上面的命令，可以创建出以 .enc 结尾的加密文件。之后可以把原始文件忽略或者移除掉。至少不要把原始文件提交到 GitHub 中，否则原始文件会显示在 GitHub 中。</p>
<p>接下来，我们告诉Travis如何对我们加密的文件就进行解密。解密过程，需要用到密码。具体使用方法跟之前创建的 KEY_PASSWORD 变量一样，输入下面命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">travis encrypt <span class="string">"ENCRYPTION_SECRET=123"</span> --add</div></pre></td></tr></table></figure></p>
<p>最后，我们需要告诉 Travis 哪些文件需要进行解密。将下面的命令添加到 .travis.yml 文件中的 before-script 部分：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">before_script:</span></div><div class="line">- openssl aes-<span class="number">256</span>-cbc -k <span class="string">"$ENCRYPTION_SECRET"</span> -<span class="keyword">in</span> scripts/profile/$PROFILE_NAME.mobileprovision.enc</div><div class="line">  -d -a -out scripts/profile/$PROFILE_NAME.mobileprovision</div><div class="line">- openssl aes-<span class="number">256</span>-cbc -k <span class="string">"$ENCRYPTION_SECRET"</span> -<span class="keyword">in</span> scripts/certs/dist.cer.enc -d -a</div><div class="line">  -out scripts/certs/dist.cer</div><div class="line">- openssl aes-<span class="number">256</span>-cbc -k <span class="string">"$ENCRYPTION_SECRET"</span> -<span class="keyword">in</span> scripts/certs/dist.p12.enc -d -a</div><div class="line">  -out scripts/certs/dist.p12</div></pre></td></tr></table></figure></p>
<p>before-script是编译脚本执行之前，会执行的操作。这样Travis就回在我们执行编译脚本之前将我们的文件解密还原成原来的文件了。</p>
<h2 id="u6DFB_u52A0_u811A_u672C"><a href="#u6DFB_u52A0_u811A_u672C" class="headerlink" title="添加脚本"></a>添加脚本</h2><p>现在我们需要确保证书都导入至 Travis CI 的钥匙串中。为此，我们需要在 scripts 文件夹中添加一个名为 add-key.sh 的文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line">security create-keychain -p travis ios-build.keychain</div><div class="line">security default-keychain -s ios-build.keychain</div><div class="line"></div><div class="line">security unlock-keychain -p travis ios-build.keychain</div><div class="line">security <span class="built_in">set</span>-keychain-settings -t 3600 -l ~/Library/Keychains/ios-build.keychain</div><div class="line"></div><div class="line">security import ./scripts/certs/dist.cer -k ~/Library/Keychains/ios-build.keychain -T /usr/bin/codesign</div><div class="line">security import ./scripts/certs/dist.p12 -k ~/Library/Keychains/ios-build.keychain -P <span class="variable">$KEY_PASSWORD</span> -T /usr/bin/codesign</div><div class="line"></div><div class="line">mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles</div><div class="line">cp ./scripts/profile/<span class="variable">$PROFILE_NAME</span>.mobileprovision ~/Library/MobileDevice/Provisioning\ Profiles/</div><div class="line"></div><div class="line">security find-identity -p codesigning ~/Library/Keychains/ios-build.keychain</div><div class="line">security list-keychain</div></pre></td></tr></table></figure></p>
<p>通过上面的命令创建了一个名为 ios-build 的临时钥匙串，里面包含了所有证书。注意，这里我们使用了 $KEY_PASSWORD 来导入私钥。最后一步是将配置文件拷贝至 Library 文件夹。</p>
<p>创建好文件之后，确保给其授予了可执行的权限：在命令行输入：chmod a+x scripts/add-key.sh 即可。为了正常使用脚本，必须要这样处理一下。</p>
<h2 id="u6307_u5B9A_u8BC1_u4E66_u7B7E_u540D_u7F16_u8BD1"><a href="#u6307_u5B9A_u8BC1_u4E66_u7B7E_u540D_u7F16_u8BD1" class="headerlink" title="指定证书签名编译"></a>指定证书签名编译</h2><p>至此，已经导入了所有的证书和配置文件，我们可以开始给应用程序签名了。接下来我们就编译用于我们证书签名的应用程序。我建议在编译命令中使用 OBJROOT 和 SYMROOT 来指定输出目录。另外，为了创建 release 版本，还需要把 SDK 设置为 iphoneos，以及将 configuration 修改为 Release：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">script:</span></div><div class="line">- xctool -workspace $APP_NAME.xcworkspace -scheme $APP_NAME -sdk iphoneos  -configuration Release OBJROOT=$PWD/build SYMROOT=$PWD/build ONLY_ACTIVE_ARCH=NO CODE_SIGN_IDENTITY=<span class="string">"$DEVELOPER_NAME"</span></div></pre></td></tr></table></figure></p>
<h2 id="u6253_u5305IPA"><a href="#u6253_u5305IPA" class="headerlink" title="打包IPA"></a>打包IPA</h2><p>我们需要在 scripts 文件夹中添加一个名为 sign-and-upload.sh 的文件，将应用程序的二进制文件打包成IPA文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$TRAVIS_PULL_REQUEST</span>"</span> != <span class="string">"false"</span> ]]; <span class="keyword">then</span></div><div class="line">  <span class="built_in">echo</span> <span class="string">"This is a pull request. No deployment will be done."</span></div><div class="line">  <span class="built_in">exit</span> 0</div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$TRAVIS_BRANCH</span>"</span> != <span class="string">"master"</span> ]]; <span class="keyword">then</span></div><div class="line">  <span class="built_in">echo</span> <span class="string">"Testing on a branch other than master. No deployment will be done."</span></div><div class="line">  <span class="built_in">exit</span> 0</div><div class="line"><span class="keyword">fi</span></div><div class="line">PROVISIONING_PROFILE=<span class="string">"<span class="variable">$HOME</span>/Library/MobileDevice/Provisioning Profiles/<span class="variable">$PROFILE_NAME</span>.mobileprovision"</span></div><div class="line">OUTPUTDIR=<span class="string">"<span class="variable">$PWD</span>/build/Release-iphoneos"</span></div><div class="line">xcrun -<span class="built_in">log</span> -sdk iphoneos PackageApplication <span class="string">"<span class="variable">$OUTPUTDIR</span>/<span class="variable">$APP_NAME</span>.app"</span> -o <span class="string">"<span class="variable">$OUTPUTDIR</span>/<span class="variable">$APP_NAME</span>.ipa"</span></div></pre></td></tr></table></figure></p>
<p>第二行至第九行非常重要。我们并不希望在某个特性分支上创建新的 release。对 pull 请求也一样的。由于安全环境变量被禁用，所以 pull 请求也不会编译。</p>
<p>第十四行，才是真正的签名操作。这个命令会在 build/Release-iphoneos 目录生成 2 个文件：TravisExample.ipa 和 TravisExample.app.dsym。第一个文件包含了分发至手机上的应用程序。dsym 文件包含了二进制文件的调试信息。这个文件对于记录设备上的 crash 信息非常重要。之后当我们部署应用程序的时候，会用到这两个文件。</p>
<p>创建好文件之后，确保给其授予了可执行的权限：在命令行输入：chmod a+x scripts/sign-and-upload.sh 即可。为了正常使用脚本，必须要这样处理一下。</p>
<h2 id="u6267_u884C_u811A_u672C"><a href="#u6267_u884C_u811A_u672C" class="headerlink" title="执行脚本"></a>执行脚本</h2><p>我们需要在 scripts 文件夹中添加一个名为 remove-key.sh 的文件，移除之前创建的临时钥匙串，并删除配置文件。虽然这不是必须的，不过这有助于进行本地测试。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line">security delete-keychain ios-build.keychain</div><div class="line">rm -f ~/Library/MobileDevice/Provisioning\ Profiles/<span class="variable">$PROFILE_NAME</span>.mobileprovision</div></pre></td></tr></table></figure></p>
<p>最后一步，我们必须告诉 Travis 什么时候执行这三个脚本。在应用程序编译、签名和清除等之前，需要先添加私钥。在 .travis.yml 文件中添加如下内容：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">before_script:</span></div><div class="line">- <span class="string">"./scripts/add-key.sh"</span></div><div class="line"><span class="symbol">script:</span></div><div class="line">- xctool -workspace $APP_NAME.xcworkspace -scheme $APP_NAME -sdk iphoneos  -configuration Release OBJROOT=$PWD/build SYMROOT=$PWD/build ONLY_ACTIVE_ARCH=NO CODE_SIGN_IDENTITY=<span class="string">"$DEVELOPER_NAME"</span></div><div class="line"><span class="symbol">after_success:</span></div><div class="line">- <span class="string">"./scripts/sign-and-upload.sh"</span></div><div class="line"><span class="symbol">after_script:</span></div><div class="line">- <span class="string">"./scripts/remove-key.sh"</span></div></pre></td></tr></table></figure></p>
<h2 id="u90E8_u7F72IPA_u5230Fir-im"><a href="#u90E8_u7F72IPA_u5230Fir-im" class="headerlink" title="部署IPA到Fir.im"></a>部署IPA到Fir.im</h2><p>创建一个Fir.im账号，并配置好应用程序。配置好应用程序后Fir.im会为每个应用程序创建一个用户Token，我们需要确保它们是加密的。执行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">travis encrypt <span class="string">"FIR_APP_TOKEN=&#123;Token&#125;&#125;"</span> --add</div></pre></td></tr></table></figure></p>
<p>编辑 scripts/sign-and-upload.sh 文件，增加以下脚本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> [ ! -z <span class="string">"<span class="variable">$FIR_APP_TOKEN</span>"</span> ]; <span class="keyword">then</span></div><div class="line">  <span class="built_in">echo</span> <span class="string">""</span></div><div class="line">  <span class="built_in">echo</span> <span class="string">"***************************"</span></div><div class="line">  <span class="built_in">echo</span> <span class="string">"*   Uploading to Fir.im   *"</span></div><div class="line">  <span class="built_in">echo</span> <span class="string">"***************************"</span></div><div class="line">  fir p <span class="variable">$OUTPUTDIR</span>/<span class="variable">$APP_NAME</span>.ipa \</div><div class="line">  -T <span class="variable">$FIR_APP_TOKEN</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure></p>
<p>最后需要添加 Fir.im 上传命令的环境。在 .travis.yml 文件中添加如下内容：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">before_install:</span></div><div class="line">- brew update</div><div class="line">- gem install fir-cli</div></pre></td></tr></table></figure></p>
<p>到这里就实现了持续集成、持续交付，并且持续部署到Fir.im，是不是很简单呢！</p>
<h1 id="u793A_u4F8B_u9879_u76EE"><a href="#u793A_u4F8B_u9879_u76EE" class="headerlink" title="示例项目"></a>示例项目</h1><ul>
<li><a href="https://github.com/yeziahehe/YFSwiftFramework" target="_blank" rel="external">YFSwiftFramework</a></li>
</ul>
<h1 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://objccn.io/issue-6-5/" target="_blank" rel="external">为 iOS 建立 Travis CI</a></li>
</ul>
<blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt=""><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2016/08/07/use_travis_ci_for_ios_project/">http://yeziahehe.com/2016/08/07/use_travis_ci_for_ios_project/</a></blockquote>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p>持续集成一直是现在非常热门的话题，通过持续集成可]]>
    </summary>
    
      <category term="iOS" scheme="http://yeziahehe.com/tags/iOS/"/>
    
      <category term="Travis CI" scheme="http://yeziahehe.com/tags/Travis-CI/"/>
    
      <category term="技术" scheme="http://yeziahehe.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift中的文件管理-NSFileManager]]></title>
    <link href="http://yeziahehe.com/2016/08/05/Swift_NSFileManager/"/>
    <id>http://yeziahehe.com/2016/08/05/Swift_NSFileManager/</id>
    <published>2016-08-05T12:03:10.000Z</published>
    <updated>2016-08-07T20:30:46.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p>由于 iOS 系统不开放的原因，用户是不可以进行文件操作的。在代码层面，应用程序都是运行在自己的沙盒中，我们只能在当前应用目录下进行文件操作。</p>
<h1 id="u6C99_u76D2_u673A_u5236"><a href="#u6C99_u76D2_u673A_u5236" class="headerlink" title="沙盒机制"></a>沙盒机制</h1><p>iOS应用程序只能对自己创建的文件系统读取文件，这个独立、封闭、安全的空间，叫做沙盒。它一般存放着程序包文件（可执行文件）、图片、音频、视频、plist文件、sqlite数据库以及其他文件。</p>
<p>模拟器沙盒的位置<code>/User/userName/Library/Application Support/iPhone Simulator</code>。</p>
<h1 id="u76EE_u5F55_u7ED3_u6784"><a href="#u76EE_u5F55_u7ED3_u6784" class="headerlink" title="目录结构"></a>目录结构</h1><p>默认情况下，每个应用的目录结构如下图所示：<br><img src="http://7xkvt5.com1.z0.glb.clouddn.com/blog/document.png" alt="document"></p>
<table>
<thead>
<tr>
<th>目录</th>
<th>是否同步到iTunes</th>
<th>说明</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>Documents</td>
<td>是</td>
<td>最常用目录，适合存储重要数据</td>
<td>不可再生的用户数据</td>
</tr>
<tr>
<td>Library/Caches</td>
<td>否</td>
<td>常用目录，适合存储缓存文件和数据</td>
<td>可再生的缓存图片、数据，==清除缓存就是清除这里的数据==</td>
</tr>
<tr>
<td>Library/Preferences</td>
<td>是</td>
<td>通常保存应用的偏好设置信息</td>
<td>NSUserDefaults</td>
</tr>
<tr>
<td>tmp</td>
<td>否</td>
<td>存放临时数据，应用退出或者手机重启后会删除文件</td>
<td>临时数据</td>
</tr>
</tbody>
</table>
<h1 id="NSFileManager"><a href="#NSFileManager" class="headerlink" title="NSFileManager"></a>NSFileManager</h1><p>NSFileManager是文件管理的对象，在使用的时候，我们通常使用了系统提供的方法：<code>NSFileManager.defaultManager()</code>,系统的方法获取了一个单例对象，线程安全的。如果在不同线程中使用，而且需要代理函数来监听事件，这时候要使用init来创建每个线程独立的fileManager。</p>
<p>通过NSFileManager获取目录和文件创建、读写、删除、重命名等操作，具体的操作可以参考<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSFileManager_Class/" target="_blank" rel="external">Apple官方文档</a> 。接下来介绍几个常用的方法。</p>
<h2 id="u83B7_u53D6_u8DEF_u5F84"><a href="#u83B7_u53D6_u8DEF_u5F84" class="headerlink" title="获取路径"></a>获取路径</h2><p>在项目中我们通常要缓存数据需要进行存放，这个时候<code>Library/Caches</code>文件目录就起到了非常重要的作用。通常使用这个方法来进统一获取这个目录，进行缓存的管理。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">yfCachesURL</span>() -&gt; <span class="title">NSURL</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">try</span>! <span class="type">NSFileManager</span>.defaultManager().<span class="type">URLForDirectory</span>(.<span class="type">CachesDirectory</span>, inDomain: .<span class="type">UserDomainMask</span>, appropriateForURL: <span class="literal">nil</span>, create: <span class="literal">false</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="u7F13_u5B58"><a href="#u7F13_u5B58" class="headerlink" title="缓存"></a>缓存</h2><p>我们通常需要在项目中显示缓存的大小，只获取缓存的图片方法并不完整，使用以下遍历<code>Library/Caches</code>文件得出的缓存大小比较准确。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">cachesSize</span>() -&gt; <span class="title">Float</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> files = <span class="type">NSFileManager</span>.defaultManager().subpathsAtPath(cacheURLStrng())</div><div class="line">    <span class="keyword">var</span> size: <span class="type">Float</span> = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> fileName <span class="keyword">in</span> files!&#123;</div><div class="line">        <span class="keyword">let</span> path = cacheURLStrng().stringByAppendingFormat(<span class="string">"/\(fileName)"</span>)</div><div class="line">        <span class="keyword">let</span> floder = <span class="keyword">try</span>! <span class="type">NSFileManager</span>.defaultManager().attributesOfItemAtPath(path)</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (abc, bcd) <span class="keyword">in</span> floder &#123;</div><div class="line">            <span class="keyword">if</span> abc == <span class="type">NSFileSize</span> &#123;</div><div class="line">                size += bcd.floatValue</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> size/(<span class="number">1024</span>*<span class="number">1024</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另外常用操作进行缓存的清除，代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">cleanCachesDirectoryAtURL</span>(<span class="title">cachesDirectoryURL</span>: <span class="title">NSURL</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> fileManager = <span class="type">NSFileManager</span>.defaultManager()</div><div class="line"></div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> fileURLs = (<span class="keyword">try</span>? fileManager.contentsOfDirectoryAtURL(cachesDirectoryURL, includingPropertiesForKeys: <span class="literal">nil</span>, options: <span class="type">NSDirectoryEnumerationOptions</span>())) &#123;</div><div class="line">        <span class="keyword">for</span> fileURL <span class="keyword">in</span> fileURLs &#123;</div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                <span class="keyword">try</span> fileManager.removeItemAtURL(fileURL)</div><div class="line">            &#125; <span class="keyword">catch</span> <span class="number">_</span> &#123;</div><div class="line">                yfLog.error(<span class="string">"Clean Caches - removeItemAtURL: \(fileURL) error!"</span>)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt=""><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2016/08/05/Swift_NSFileManager/">http://yeziahehe.com/2016/08/05/Swift_NSFileManager/</a></blockquote>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p>由于 iOS 系统不开放的原因，用户是不可以进行]]>
    </summary>
    
      <category term="iOS" scheme="http://yeziahehe.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://yeziahehe.com/tags/Swift/"/>
    
      <category term="技术" scheme="http://yeziahehe.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一步一步学习Swift]]></title>
    <link href="http://yeziahehe.com/2016/03/08/step_by_step_learn_swift/"/>
    <id>http://yeziahehe.com/2016/03/08/step_by_step_learn_swift/</id>
    <published>2016-03-08T07:26:31.000Z</published>
    <updated>2016-08-07T20:30:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p>记得年初定计划的时候说了每年要学习一门语言，加上知道以后工作中肯定不可避免的要使用 Swift 来进行 iOS 的开发，于是开始了 Swift 的升级之路。</p>
<p>碰巧今天和薄荷的 CTO Vincent 聊天的时候说到，Swift 是 iOS 开发的未来，灵光一闪，觉得自己可以写一个入门的博客，帮助更多想要学习 Swift 的同学学习更加有计划和方向，万一我以后也做了 CTO 才不想一遍遍的培训，只要看我这个博客就行了，一劳永逸！</p>
<h1 id="u5DE5_u5177"><a href="#u5DE5_u5177" class="headerlink" title="工具"></a>工具</h1><p>请不要忘记想要学习一个东西的时候，最好的地方是全球最大的 <strong>同性恋交友网站 <a href="https://github.com/search?o=desc&amp;q=swift&amp;s=stars&amp;type=Repositories&amp;utf8=%E2%9C%93" target="_blank" rel="external">Github</a></strong> 。输入要学习的 keyword，choose most star，基本上把前五页的 repo 看完你肯定入门了。</p>
<p><img src="http://7xkvt5.com1.z0.glb.clouddn.com/blog%2Fgithub.png" alt="github"></p>
<h1 id="u8D44_u6E90"><a href="#u8D44_u6E90" class="headerlink" title="资源"></a>资源</h1><p>首先，Swfit 是开源的，这个对于开发者来说应该是最开心的事情，可以了解到这门语言的实现。学习一门语言最重要的就是关注官方放出来的资料，全面、规范、最新是最大的优势，这里隆重的给出官方的资源网站 <a href="https://developer.apple.com/swift/resources/" target="_blank" rel="external">Swift Resources</a>。</p>
<p><img src="http://7xkvt5.com1.z0.glb.clouddn.com/blog%2Fswift_reference.png" alt="swift_reference"></p>
<p>上图的 Guides and Reference 中可以看到，这里有本非常出名的官方给的 <strong>The Swift Programming Language</strong> 书籍，我个人的建议是如果你对计算机一些专业英文词汇不熟悉，建议可以阅读 <strong>梁杰发起&amp;一群iOS小伙伴</strong> 翻译的<a href="http://wiki.jikexueyuan.com/project/swift/" target="_blank" rel="external">中文版</a>，推荐大家下载 epub ，阅读体验非常好，对他们为营造更好的社区做出的贡献表示感谢。</p>
<p>另外一本 <strong>Using Swift with Cocoa and Objective-C</strong> 书籍，同样是官方推荐的，这里给大家配上<a href="https://github.com/CocoaChina-editors/Welcome-to-Swift/blob/master/UsingSwiftwithCocoaandObjective-C%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C.md" target="_blank" rel="external">中文版</a>（其实我英文还好，但是这种专业性词汇太强的书籍，看中文更加有益于理解）。</p>
<p><strong>先花时间把上面的两本书看完呗！然后再接着看下面的教程我相信你会信心满满的！</strong></p>
<h2 id="Github_Awesome-Swift"><a href="#Github_Awesome-Swift" class="headerlink" title="Github Awesome-Swift"></a>Github Awesome-Swift</h2><p>Swift 的资源整理，有三个不错的外国整理的 Awesome-Swift，<a href="https://github.com/matteocrippa/awesome-swift" target="_blank" rel="external">1</a>，<a href="https://github.com/Wolg/awesome-swift" target="_blank" rel="external">2</a>，<a href="https://github.com/vsouza/awesome-ios" target="_blank" rel="external">3</a>。另外，国人整理的<a href="https://github.com/ipader/SwiftGuide" target="_blank" rel="external">Swift语言指南</a>对于入门 Swift 的人来说是一大福音，希望大家都能好好的利用起来资源。</p>
<p>【未完待续】</p>
<blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt=""><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2016/03/08/step_by_step_learn_swift/">http://yeziahehe.com/2016/03/08/step_by_step_learn_swift/</a></blockquote>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p>记得年初定计划的时候说了每年要学习一门语言，加上]]>
    </summary>
    
      <category term="iOS" scheme="http://yeziahehe.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://yeziahehe.com/tags/Swift/"/>
    
      <category term="技术" scheme="http://yeziahehe.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2016年书单和购物清单]]></title>
    <link href="http://yeziahehe.com/2016/01/09/2016_year_book_list/"/>
    <id>http://yeziahehe.com/2016/01/09/2016_year_book_list/</id>
    <published>2016-01-09T12:07:02.000Z</published>
    <updated>2016-09-02T03:04:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p>2016年的目标是读80本书，以前开复老师在微博上面讲过，一年读到100本书才算合格。今年的计划是80本书，在范围上，首先从手上买的一堆技术书籍开始，在逐步扩充到其他类别的图书。<br>另外今年手头上的设备慢慢要开始换了，这四年上大学都是老爸老妈给买的，准备开始逐步自己进行更换。</p>
<h1 id="u4E66_u7C4D"><a href="#u4E66_u7C4D" class="headerlink" title="书籍"></a>书籍</h1><p>目前罗列29本。</p>
<h2 id="u6280_u672F"><a href="#u6280_u672F" class="headerlink" title="技术"></a>技术</h2><ul>
<li>《啊哈！算法》</li>
<li>《程序员修炼之道–从小工到专家》</li>
<li>《剑指Offer 名企面试官精讲典型编程题》</li>
<li>《编程之美–微软技术面试心得》</li>
<li>《从0到1 开启商业与未来的秘密》</li>
<li>《C++数据结构与程序设计》</li>
<li>《算法导论》</li>
<li>《代码整洁之道》</li>
<li>《程序员的自我修养：链接、装载与库》</li>
<li>《算法》</li>
<li>《Objective-C高级编程iOS与OS X多线程和内存管理》</li>
<li>《编程珠玑》</li>
<li>《人月神话》</li>
<li>《重构 改善既有代码的设计》</li>
<li>《编程之法：面试和算法心得》</li>
</ul>
<h2 id="u4F20_u8BB0"><a href="#u4F20_u8BB0" class="headerlink" title="传记"></a>传记</h2><ul>
<li>《Steve Jobs》</li>
</ul>
<h2 id="u6742_u8C08"><a href="#u6742_u8C08" class="headerlink" title="杂谈"></a>杂谈</h2><ul>
<li>《1Q84》</li>
<li>《国富论》</li>
<li>《哈默手稿》</li>
<li>《我所理解的生活》</li>
<li>《最好的告别：关于衰老与死亡，你必须知道的常识》</li>
<li>《人类简史 从动物到上帝》</li>
<li>《万物：创世》</li>
<li>《东大爸爸写给我的日本史》</li>
<li>《西方音乐史十讲》</li>
<li>《日本史（1600-2000）》</li>
<li>《硅谷之谜》</li>
<li>《浪潮之巅》</li>
<li>《摄影笔记》</li>
<li>《本色》</li>
<li>《色眼识人》</li>
<li>《色眼再识人》</li>
</ul>
<h1 id="u9884_u8D2D_u6E05_u5355"><a href="#u9884_u8D2D_u6E05_u5355" class="headerlink" title="预购清单"></a>预购清单</h1><p>从上到下依次为更换顺序</p>
<h2 id="u8BBE_u5907"><a href="#u8BBE_u5907" class="headerlink" title="设备"></a>设备</h2><ul>
<li>单反（型号正在对比中）</li>
<li>MacBook Pro 15 (目前使用Macbook Pro 13 mid 2012)</li>
<li>HHKB Pro (目前使用的斗鱼黑轴，别问为什么，买回来撸的)</li>
<li>iPhone (目前使用的iPhone 5s)</li>
</ul>
<h2 id="u5316_u5986_u54C1"><a href="#u5316_u5986_u54C1" class="headerlink" title="化妆品"></a>化妆品</h2><p>男人也好好好的保养，要做个精致的人。</p>
<ul>
<li>kiehl’s    ultra facial cleanser(冬季用)</li>
<li>kiehl’s    RARE EARTH DEEP PORE CLEANSING MASQUE-亚马逊白泥清洁面膜(冬季用)</li>
<li>kiehl’s    金盏花水(冬季用)</li>
<li>kiehl’s    ULTRA FACIAL CREAM(冬季用)</li>
</ul>
<blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt=""><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2016/01/09/2016_year_book_list/">http://yeziahehe.com/2016/01/09/2016_year_book_list/</a></blockquote>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p>2016年的目标是读80本书，以前开复老师在微博]]>
    </summary>
    
      <category term="读书" scheme="http://yeziahehe.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="生活" scheme="http://yeziahehe.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="读书" scheme="http://yeziahehe.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Objective-C封装技巧（三）：比继承更加灵活的overwrite方法 -- Method Swizzling]]></title>
    <link href="http://yeziahehe.com/2016/01/06/Objective-C_package_skill(3)%EF%BC%9Aoverwrite_method--%20Method%20Swizzling/"/>
    <id>http://yeziahehe.com/2016/01/06/Objective-C_package_skill(3)：overwrite_method-- Method Swizzling/</id>
    <published>2016-01-06T02:38:24.000Z</published>
    <updated>2016-08-07T20:30:55.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p>有经验的工程师在经历过一些项目之后，会慢慢的去考虑之前项目中遇到的坑，思考的过程中就会诞生设计模式和架构的雏形。我这次毕业设计的项目架构正在酝酿中，因为自己本身经验并没有很丰富，所以浅谈自己封装的一些想法，权当抛砖引玉。</p>
<p>平时项目中我们经常会对重复使用的代码进行封装，那么对于封装的场景是否有过思考？是否想过各种封装方法的使用场景和原则。我们实现提出在封装常用的方法：继承和Category。另外在继承的基础上我们发现了比继承更加灵活的Swizzling和在Category的使用过程出现的Associated Objects。关于上述的所有方法，我将会写一个系列来阐述。</p>
<ul>
<li><a href="http://yeziahehe.com/2016/01/05/Objective-C%E5%B0%81%E8%A3%85%E6%8A%80%E5%B7%A7%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ACategory%E5%92%8C%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8D%9A%E5%BC%88/">Objective-C封装技巧（一）：Category和继承的博弈</a></li>
<li><a href="http://yeziahehe.com/2016/01/06/Objective-C%E5%B0%81%E8%A3%85%E6%8A%80%E5%B7%A7%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%B8%8E%E2%80%9C%E9%AD%94%E9%AC%BC%E7%9A%84%E4%BA%A4%E6%98%93%E2%80%9D%20--%20Associated%20Objects/">Objective-C封装技巧（二）：与“魔鬼的交易” – Associated Objects</a></li>
<li><a href="http://yeziahehe.com/2016/01/06/Objective-C%E5%B0%81%E8%A3%85%E6%8A%80%E5%B7%A7%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%AF%94%E7%BB%A7%E6%89%BF%E6%9B%B4%E5%8A%A0%E7%81%B5%E6%B4%BB%E7%9A%84overwrite%E6%96%B9%E6%B3%95%20--%20Method%20Swizzling/">Objective-C封装技巧（三）：比继承更加灵活的overwrite方法 – Method Swizzling</a></li>
</ul>
<h1 id="u63D0_u51FA_u95EE_u9898"><a href="#u63D0_u51FA_u95EE_u9898" class="headerlink" title="提出问题"></a>提出问题</h1><p>希望大家在看系列文章之前，首先思考下面提出的几个问题：</p>
<ol>
<li>对于方法封装，我们平时经常使用的就是继承子类化Base基类和使用Category，那么在使用这两个方法是具体场景是什么？它们之前的区别和使用优先原则是什么？</li>
<li>Category不允许自定义实例属性的缺点，可以用什么来弥补？（提示：Associated Objects）Associated Objects的具体使用场景又是什么呢？</li>
<li>对于需要重复写的通用方法，又存在生命周期中的方法，除了工厂方法继承多个工厂类，还有没有更好的封装机制？（提示：Method Swizzling）关于Method Swizzling的使用场景和机制是什么？<br>本篇博客对第三个问题进行回答分析，如果阐述过程中有错误或者疑问，大家可以在文章下面留言。</li>
</ol>
<h1 id="u524D_u63D0"><a href="#u524D_u63D0" class="headerlink" title="前提"></a>前提</h1><p>在我们对继承进行使用的时候，通常有个使用场景，类似于UMeng的对用户行为进行追踪和分析的操作。通常有这么三种做法：</p>
<ul>
<li>简单粗暴，直接修改每个页面的 <strong>view controller</strong> 代码，简单粗暴；</li>
<li>子类化一个Base基类，在基类的 <strong>view controller</strong> 代码里面进行操作；</li>
<li>Category来进行方法的扩展，然后在<strong>view controller</strong> 代码里面进行调用；</li>
<li>Method Swizzling<br><img src="http://7xkvt5.com1.z0.glb.clouddn.com/package%2FUMeng.png" alt="UMeng"></li>
</ul>
<p>1，2，3两种的方法，通常会造成大量的重复代码，显得代码很不优雅。1的方法还会存在忘记添加的情况，2的方法存在需要子类化多个子类，如 <strong>UIViewController</strong> 、 <strong>UITableViewController</strong> 、 <strong>UINavigationController</strong>。3的方法只能对代码量并没有缩减，用在这个场景下也不合适。</p>
<h1 id="Method_Swizzling"><a href="#Method_Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h1><p>这个时候我们想用优雅的方式来解决这个问题，既不影响当前方法的实现，又能够在方法注入一些新的操作，动态的来增加方法。我们引入了runtime中的技术方案 – Method Swizzling。利用的是@selector机制，修改响应事件或者方法所对应的函数指针。</p>
<h2 id="u4F7F_u7528_u573A_u666F"><a href="#u4F7F_u7528_u573A_u666F" class="headerlink" title="使用场景"></a>使用场景</h2><p>大致可以概括成下列三个场景：</p>
<ul>
<li>在向视图控制器的生命周期中注入操作、事件的响应、视图的绘制；</li>
<li>Foundation中的网络堆栈中对于调用时机的记录；</li>
<li>类似于Logging，Analytics，Authentication和Caching。这些事务琐碎，跟主要业务逻辑无关，在很多地方都有，又很难抽象出来单独的模块。</li>
</ul>
<h2 id="u4EE3_u7801"><a href="#u4EE3_u7801" class="headerlink" title="代码"></a>代码</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"MobClick.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIViewController</span> (<span class="title">MRCUMAnalytics</span>)</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">YFUMengAnalytics</span>)</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)swizzleMethod(Class <span class="keyword">class</span>, SEL originalSelector, SEL swizzledSelector) &#123;</div><div class="line">    <span class="comment">// the method might not exist in the class, but in its superclass</span></div><div class="line">    Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</div><div class="line">    Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector);</div><div class="line"></div><div class="line">    <span class="comment">// class_addMethod will fail if original method already exists</span></div><div class="line">    <span class="built_in">BOOL</span> didAddMethod = class_addMethod(<span class="keyword">class</span>, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</div><div class="line"></div><div class="line">    <span class="comment">// the method doesn’t exist and we just added one</span></div><div class="line">    <span class="keyword">if</span> (didAddMethod) &#123;</div><div class="line">        class_replaceMethod(<span class="keyword">class</span>, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)load &#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];</div><div class="line">        <span class="comment">// When swizzling a class method, use the following:</span></div><div class="line">        <span class="comment">// Class class = object_getClass((id)self);</span></div><div class="line">        swizzleMethod(<span class="keyword">class</span>, <span class="keyword">@selector</span>(viewDidAppear:), <span class="keyword">@selector</span>(umeng_viewWillAppear:));</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)umeng_viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    [<span class="keyword">self</span> umeng_viewWillAppear:animated];</div><div class="line">    [MobClick beginLogPageView:<span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>])];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h2 id="u89E3_u91CA"><a href="#u89E3_u91CA" class="headerlink" title="解释"></a>解释</h2><ul>
<li><p>不需要显性调用<br>我们发现我们使用了Method Swizzling之后，对现有的方法进行了新方法的注入，我们在调用现有方法的时候，就会自动触发我们注入的方法。这种做法非常类似于Hook。</p>
</li>
<li><p>步骤</p>
</li>
</ul>
<ol>
<li><p>创建需要交换的方法 <strong>- (void)umeng_viewWillAppear:(BOOL)animated</strong> ，在方法中添加需要实现的方法。这里有个问题解释下，为什么umeng_viewWillAppear又调用了自身？首先我们通过Method Swizzling之后，这两个方法的实现是被交换的，也就是说在定义的时候这样写，但是在实际调用的时候这个方法调用的viewWillAppear，而在viewWillAppear中调用的是umeng_viewWillAppear。</p>
</li>
<li><p>进行方法的交换 <strong>- (void)swizzleMethod(Class class, SEL originalSelector, SEL swizzledSelector)</strong> ，这一步是具体的实现过程。将两个方法进行交换。我们发现其中有一个判断条件，是否是增加方法。通常使用Method Swizzling是来进行方法的增加，而不是单纯的替换，所以说会进行判断。</p>
</li>
<li><p>触发时间，是通过 <strong>+ (void)load</strong> 方法来触发。关于这个方法的调用时间是在类被加载的时候调用的，此外load方法还有一个非常重要的特性，那就是子类、父类和分类中的load方法的实现是被区别对待的。换句话说在 Objective-C runtime 自动调用load方法时，分类中的load方法并不会对主类中的load方法造成覆盖。</p>
</li>
</ol>
<h1 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h1><p>至此，有关于这个系列的所有文章都已经结束，希望大家能够从文章有所收获，在自己的项目里面用到这些，多思考多重构。</p>
<blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt=""><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2016/01/06/Objective-C_package_skill(3)：overwrite_method--">http://yeziahehe.com/2016/01/06/Objective-C_package_skill(3)：overwrite_method--</a> Method Swizzling/</blockquote>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p>有经验的工程师在经历过一些项目之后，会慢慢的去考]]>
    </summary>
    
      <category term="iOS" scheme="http://yeziahehe.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://yeziahehe.com/tags/Objective-C/"/>
    
      <category term="封装" scheme="http://yeziahehe.com/tags/%E5%B0%81%E8%A3%85/"/>
    
      <category term="Swizzling" scheme="http://yeziahehe.com/tags/Swizzling/"/>
    
      <category term="技术" scheme="http://yeziahehe.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Objective-C封装技巧（二）：与“魔鬼的交易” -- Associated Objects]]></title>
    <link href="http://yeziahehe.com/2016/01/06/Objective-C_package_skill(2)%EF%BC%9A%20--%20Associated%20Objects/"/>
    <id>http://yeziahehe.com/2016/01/06/Objective-C_package_skill(2)： -- Associated Objects/</id>
    <published>2016-01-06T01:42:32.000Z</published>
    <updated>2016-08-07T20:31:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p>有经验的工程师在经历过一些项目之后，会慢慢的去考虑之前项目中遇到的坑，思考的过程中就会诞生设计模式和架构的雏形。我这次毕业设计的项目架构正在酝酿中，因为自己本身经验并没有很丰富，所以浅谈自己封装的一些想法，权当抛砖引玉。</p>
<p>平时项目中我们经常会对重复使用的代码进行封装，那么对于封装的场景是否有过思考？是否想过各种封装方法的使用场景和原则。我们实现提出在封装常用的方法：继承和Category。另外在继承的基础上我们发现了比继承更加灵活的Swizzling和在Category的使用过程出现的Associated Objects。关于上述的所有方法，我将会写一个系列来阐述。</p>
<ul>
<li><a href="http://yeziahehe.com/2016/01/05/Objective-C%E5%B0%81%E8%A3%85%E6%8A%80%E5%B7%A7%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ACategory%E5%92%8C%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8D%9A%E5%BC%88/">Objective-C封装技巧（一）：Category和继承的博弈</a></li>
<li><a href="http://yeziahehe.com/2016/01/06/Objective-C%E5%B0%81%E8%A3%85%E6%8A%80%E5%B7%A7%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%B8%8E%E2%80%9C%E9%AD%94%E9%AC%BC%E7%9A%84%E4%BA%A4%E6%98%93%E2%80%9D%20--%20Associated%20Objects/">Objective-C封装技巧（二）：与“魔鬼的交易” – Associated Objects</a></li>
<li><a href="http://yeziahehe.com/2016/01/06/Objective-C%E5%B0%81%E8%A3%85%E6%8A%80%E5%B7%A7%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%AF%94%E7%BB%A7%E6%89%BF%E6%9B%B4%E5%8A%A0%E7%81%B5%E6%B4%BB%E7%9A%84overwrite%E6%96%B9%E6%B3%95%20--%20Method%20Swizzling/">Objective-C封装技巧（三）：比继承更加灵活的overwrite方法 – Method Swizzling</a></li>
</ul>
<h1 id="u63D0_u51FA_u95EE_u9898"><a href="#u63D0_u51FA_u95EE_u9898" class="headerlink" title="提出问题"></a>提出问题</h1><p>希望大家在看系列文章之前，首先思考下面提出的几个问题：</p>
<ol>
<li>对于方法封装，我们平时经常使用的就是继承子类化Base基类和使用Category，那么在使用这两个方法是具体场景是什么？它们之前的区别和使用优先原则是什么？</li>
<li>Category不允许自定义实例属性的缺点，可以用什么来弥补？（提示：Associated Objects）Associated Objects的具体使用场景又是什么呢？</li>
<li>对于需要重复写的通用方法，又存在生命周期中的方法，除了工厂方法继承多个工厂类，还有没有更好的封装机制？（提示：Method Swizzling）关于Method Swizzling的使用场景和机制是什么？<br>本篇博客对第二个问题进行回答分析，如果阐述过程中有错误或者疑问，大家可以在文章下面留言。</li>
</ol>
<h1 id="Associated_Objects"><a href="#Associated_Objects" class="headerlink" title="Associated Objects"></a>Associated Objects</h1><p>我们知道上次再写Category的时候提到了Category的缺点，不能自定义实例变量。我们在上篇博客的中给出的答案是可以考虑继承，这里引入一个新的技术方案 – Associated Objects。</p>
<h2 id="u524D_u63D0"><a href="#u524D_u63D0" class="headerlink" title="前提"></a>前提</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#import &lt;objc/runtime.h&gt;</div></pre></td></tr></table></figure>
<p>首先需要导入runtime这个类，runtime是个双刃剑。大家使用的时候一定要小心。Associated Objects就是其中一个利器。<br>有关于runtime，可以参考下Apple官方的<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/ObjCRuntimeRef/#//apple_ref/c/func/objc_setAssociatedObject" target="_blank" rel="external">文档</a>。</p>
<h2 id="u5F00_u59CB"><a href="#u5F00_u59CB" class="headerlink" title="开始"></a>开始</h2><p>Associated Objects弥补了Objective-C不能在存在的类中扩展自定义属性的缺点，非常的便捷。Associated Objects（对相关联），用一句通俗的话来概括下就是将键值对在运行是关联到对象函数。<br>一共三个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);</div><div class="line">id objc_getAssociatedObject(id object, const void *key);</div><div class="line">void objc_removeAssociatedObjects(id object);</div></pre></td></tr></table></figure></p>
<h2 id="u521B_u5EFA_u5173_u8054"><a href="#u521B_u5EFA_u5173_u8054" class="headerlink" title="创建关联"></a>创建关联</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);</div></pre></td></tr></table></figure>
<p>一共需要四个参数：源对象，关键字，关联的对象和一个关联策略。我们一一解释。</p>
<ul>
<li><strong>object</strong> 源对象：需要进行关联的对象。                                                                        </li>
<li><strong>key</strong> 关键字：关键字是一个void类型的指针。每一个关联的关键字必须是唯一的。有三种方式来进行关键的定义，下面会给出。      </li>
<li><strong>value</strong> 关联的对象：在Catogory中一般就是自定义的变量。                                                         </li>
<li><strong>policy</strong> 关联策略：相关的对象是通过赋值，保留引用还是复制的方式、通过原子还是非原子的方式进行关联。一共有五种方式，下面给出。</li>
</ul>
<h3 id="key-_u5173_u952E_u5B57_u5B9A_u4E49"><a href="#key-_u5173_u952E_u5B57_u5B9A_u4E49" class="headerlink" title="key-关键字定义"></a>key-关键字定义</h3><ol>
<li>声明 <strong>static char kAssociatedObjectKey;</strong> ，使用 <strong>&amp;kAssociatedObjectKey</strong> 作为key值;</li>
<li>声明 <strong>static void *kAssociatedObjectKey = &kAssociatedObjectKey;</strong>，使用 <strong>kAssociatedObjectKey</strong> 作为key值；</li>
<li>使用 <strong>selector</strong> ，使用getter方法的名称 <strong>@selector(associatedObject)</strong> 作为 key 值。</li>
</ol>
<p>通常使用 <strong>static char</strong> 类型来定义，更加推荐的是指针类型。另外，尽量保证该属性是常量且唯一，试用范围在本类当中。当然有的人喜欢 <strong>selector</strong> 的方式，因为解决了计算机中最难的取名字问题。</p>
<h3 id="policy-_u5173_u8054_u5BF9_u8C61_u7684_u884C_u4E3A"><a href="#policy-_u5173_u8054_u5BF9_u8C61_u7684_u884C_u4E3A" class="headerlink" title="policy-关联对象的行为"></a>policy-关联对象的行为</h3><table>
<thead>
<tr>
<th>Behavior</th>
<th style="text-align:center">@property</th>
<th style="text-align:right">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>OBJC_ASSOCIATION_ASSIGN</td>
<td style="text-align:center">@property (assign)</td>
<td style="text-align:right">指定一个关联对象的弱引用。</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>
<td style="text-align:center">@property (nonatomic, strong)</td>
<td style="text-align:right">指定一个关联对象的强引用，不能被原子化使用。</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY_NONATOMIC</td>
<td style="text-align:center">@property (nonatomic, copy)</td>
<td style="text-align:right">指定一个关联对象的copy引用，不能被原子化使用。</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN</td>
<td style="text-align:center">@property (atomic, strong)</td>
<td style="text-align:right">指定一个关联对象的强引用，能被原子化使用。</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY</td>
<td style="text-align:center">@property (atomic, copy)</td>
<td style="text-align:right">指定一个关联对象的copy引用，能被原子化使用。</td>
</tr>
</tbody>
</table>
<h2 id="u83B7_u53D6_u5173_u8054"><a href="#u83B7_u53D6_u5173_u8054" class="headerlink" title="获取关联"></a>获取关联</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id objc_getAssociatedObject(id object, const void *key);</div></pre></td></tr></table></figure>
<p>这个非常简单，不再赘述。</p>
<h2 id="u65AD_u5F00_u5173_u8054"><a href="#u65AD_u5F00_u5173_u8054" class="headerlink" title="断开关联"></a>断开关联</h2><p>理论上说，我们会使用 <strong>void objc_removeAssociatedObjects(id object);</strong> 但是我们不应手动去调用这个函数。</p>
<blockquote>
<p>此函数的主要目的是在“初试状态”时方便地返回一个对象。你不应该用这个函数来删除对象的属性，因为可能会导致其他客户对其添加的属性也被移除了。规范的方法是：调用 objc_setAssociatedObject 方法并传入一个 nil 值来清除一个关联。</p>
</blockquote>
<p>通常这样去断开关联<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_setAssociatedObject(array, &amp;overviewKey, nil, OBJC_ASSOCIATION_ASSIGN);</div></pre></td></tr></table></figure></p>
<h2 id="u751F_u547D_u5468_u671F"><a href="#u751F_u547D_u5468_u671F" class="headerlink" title="生命周期"></a>生命周期</h2><blockquote>
<p>根据 WWDC 2011, Session 322 (第36分22秒) 中发布的内存销毁时间表，被关联的对象在生命周期内要比对象本身释放的晚很多。它们会在被 NSObject -dealloc 调用的 object_dispose() 方法中释放。</p>
<p>关联对象的释放时机与移除时机并不总是一致，比如实验中用关联策略 OBJC_ASSOCIATION_ASSIGN 进行关联的对象，很早就已经被释放了，但是并没有被移除，而再使用这个关联对象时就会造成 Crash 。</p>
</blockquote>
<h2 id="u4EE3_u7801_u793A_u4F8B"><a href="#u4EE3_u7801_u793A_u4F8B" class="headerlink" title="代码示例"></a>代码示例</h2><p>这里附上<a href="https://github.com/ibireme" target="_blank" rel="external">Yaoyuan</a>大神对于Associated Objects的具体实现：</p>
<p><strong>UIBarButtonItem+YYAdd.h</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> Provides extensions for `UIBarButtonItem`.</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIBarButtonItem</span> (<span class="title">YYAdd</span>)</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> The block that invoked when the item is selected. The objects captured by block</div><div class="line"> will retained by the ButtonItem.</div><div class="line"></div><div class="line"> @discussion This param is conflict with `target` and `action` property.</div><div class="line"> Set this will set `target` and `action` property to some internal objects.</div><div class="line"> */</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">void</span> (^actionBlock)(<span class="keyword">id</span>);</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p><strong>UIBarButtonItem+YYAdd.m</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"UIBarButtonItem+YYAdd.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"YYCategoriesMacro.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"></div><div class="line">YYSYNTH_DUMMY_CLASS(<span class="built_in">UIBarButtonItem_YYAdd</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> block_key;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYUIBarButtonItemBlockTarget</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">void</span> (^block)(<span class="keyword">id</span> sender);</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)initWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> sender))block;</div><div class="line">- (<span class="keyword">void</span>)invoke:(<span class="keyword">id</span>)sender;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">_YYUIBarButtonItemBlockTarget</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)initWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> sender))block&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        _block = [block <span class="keyword">copy</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)invoke:(<span class="keyword">id</span>)sender &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.block) <span class="keyword">self</span>.block(sender);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIBarButtonItem</span> (<span class="title">YYAdd</span>)</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setActionBlock:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> sender))block &#123;</div><div class="line">    _YYUIBarButtonItemBlockTarget *target = [[_YYUIBarButtonItemBlockTarget alloc] initWithBlock:block];</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;block_key, target, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line"></div><div class="line">    [<span class="keyword">self</span> setTarget:target];</div><div class="line">    [<span class="keyword">self</span> setAction:<span class="keyword">@selector</span>(invoke:)];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span> (^)(<span class="keyword">id</span>)) actionBlock &#123;</div><div class="line">    _YYUIBarButtonItemBlockTarget *target = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;block_key);</div><div class="line">    <span class="keyword">return</span> target.block;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<h1 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h1><p>对于Associated Objects，提供一种为Category添加自定义属性的方法。那么，在我们有自定义属性的时候，我们去使用继承还是使用Associated Objects呢？<a href="https://github.com/ibireme" target="_blank" rel="external">Yaoyuan</a>大神在issue中这样回复我：<br><img src="http://7xkvt5.com1.z0.glb.clouddn.com/package%2FAssociatedObjects.png" alt="比较"></p>
<p>所以大家还是根据自己的使用场景去确定，最后一个问题将在下篇博客中进行讲解。</p>
<blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt=""><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2016/01/06/Objective-C_package_skill(2)：">http://yeziahehe.com/2016/01/06/Objective-C_package_skill(2)：</a> – Associated Objects/</blockquote>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p>有经验的工程师在经历过一些项目之后，会慢慢的去考]]>
    </summary>
    
      <category term="iOS" scheme="http://yeziahehe.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://yeziahehe.com/tags/Objective-C/"/>
    
      <category term="runtime" scheme="http://yeziahehe.com/tags/runtime/"/>
    
      <category term="category" scheme="http://yeziahehe.com/tags/category/"/>
    
      <category term="技术" scheme="http://yeziahehe.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Objective-C封装技巧（一）：Category和继承的博弈]]></title>
    <link href="http://yeziahehe.com/2016/01/05/Objective-C_package_skill(1)%EF%BC%9ACategory_and_inherit/"/>
    <id>http://yeziahehe.com/2016/01/05/Objective-C_package_skill(1)：Category_and_inherit/</id>
    <published>2016-01-05T07:24:19.000Z</published>
    <updated>2016-08-07T20:31:05.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p>有经验的工程师在经历过一些项目之后，会慢慢的去考虑之前项目中遇到的坑，思考的过程中就会诞生设计模式和架构的雏形。我这次毕业设计的项目架构正在酝酿中，因为自己本身经验并没有很丰富，所以浅谈自己封装的一些想法，权当抛砖引玉。</p>
<p>平时项目中我们经常会对重复使用的代码进行封装，那么对于封装的场景是否有过思考？是否想过各种封装方法的使用场景和原则。我们实现提出在封装常用的方法：继承和Category。另外在继承的基础上我们发现了比继承更加灵活的Swizzling和在Category的使用过程出现的Associated Objects。关于上述的所有方法，我将会写一个系列来阐述。</p>
<ul>
<li><a href="http://yeziahehe.com/2016/01/05/Objective-C%E5%B0%81%E8%A3%85%E6%8A%80%E5%B7%A7%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ACategory%E5%92%8C%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8D%9A%E5%BC%88/">Objective-C封装技巧（一）：Category和继承的博弈</a></li>
<li><a href="http://yeziahehe.com/2016/01/06/Objective-C%E5%B0%81%E8%A3%85%E6%8A%80%E5%B7%A7%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%B8%8E%E2%80%9C%E9%AD%94%E9%AC%BC%E7%9A%84%E4%BA%A4%E6%98%93%E2%80%9D%20--%20Associated%20Objects/">Objective-C封装技巧（二）：与“魔鬼的交易” – Associated Objects</a></li>
<li><a href="http://yeziahehe.com/2016/01/06/Objective-C%E5%B0%81%E8%A3%85%E6%8A%80%E5%B7%A7%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%AF%94%E7%BB%A7%E6%89%BF%E6%9B%B4%E5%8A%A0%E7%81%B5%E6%B4%BB%E7%9A%84overwrite%E6%96%B9%E6%B3%95%20--%20Method%20Swizzling/">Objective-C封装技巧（三）：比继承更加灵活的overwrite方法 – Method Swizzling</a></li>
</ul>
<h1 id="u63D0_u51FA_u95EE_u9898"><a href="#u63D0_u51FA_u95EE_u9898" class="headerlink" title="提出问题"></a>提出问题</h1><p>希望大家在看系列文章之前，首先思考下面提出的几个问题：</p>
<ol>
<li>对于方法封装，我们平时经常使用的就是继承子类化Base基类和使用Category，那么在使用这两个方法是具体场景是什么？它们之前的区别和使用优先原则是什么？</li>
<li>Category不允许自定义实例属性的缺点，可以用什么来弥补？（提示：Associated Objects）Associated Objects的具体使用场景又是什么呢？</li>
<li>对于需要重复写的通用方法，又存在生命周期中的方法，除了工厂方法继承多个工厂类，还有没有更好的封装机制？（提示：Method Swizzling）关于Method Swizzling的使用场景和机制是什么？<br>本篇博客对第一个问题进行回答分析，如果阐述过程中有错误或者疑问，大家可以在文章下面留言。</li>
</ol>
<h1 id="u7EE7_u627F_u2013_u5B50_u7C7B_u5316"><a href="#u7EE7_u627F_u2013_u5B50_u7C7B_u5316" class="headerlink" title="继承–子类化"></a>继承–子类化</h1><p>我们首先从继承–对面对象的三大基本特征讲起，继承的概念得益于能够方便的对父类的方法进行实现和overwrite。在使用场景上，我想很多开发者应该在项目之初会经常写了很多Base的基类，封装一些基本的常用方法，在子类中可以直接实用，防止大量的重复代码。下图，使用的是<a href="https://github.com/DeveloperLx" target="_blank" rel="external">DeveloperLx</a>大神的项目框架，特此表示感谢，我也从他的框架中学到了很多。<br><img src="http://7xkvt5.com1.z0.glb.clouddn.com/package%2Fbaseclass.png" alt="baseclass"></p>
<p>应该说所有人的最初封装都是从继承开始，这个是最容易想到的方法。那么这个继承使用的场景其实是在我们需要对方法进行重写的时候（如生命周期等等，当然其实有更好的方法替代），或者对于父类Delegate通用方法来进行封装的时候来使用。但是继承的缺点在于耦合度比较高，比如我们写了BaseViewController来进行继承，那么通用模块移植到别的项目中的时候就会出现依赖于BaseViewController基类的问题。出现了非常高的耦合度，所以我们经常在面试题中，面试官也会问你这样的问题：你项目中使用继承吗？优缺点？是否有改进的方法？</p>
<h1 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h1><p>说到Category，大家肯定不陌生，可以看到Apple官方也大量的使用了Category。Category使用的设计模式其实就是装饰模式，是对于改设计模式的具体实现。Category区别于继承的最大不同点在于，它是在不改变原有类的前提下，动态的去扩展该类的类方法和实例方法。</p>
<h2 id="u4F7F_u7528_u573A_u666F"><a href="#u4F7F_u7528_u573A_u666F" class="headerlink" title="使用场景"></a>使用场景</h2><p>对于Category的使用场景，我们根据<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html#//apple_ref/doc/uid/TP40008195-CH5-SW1" target="_blank" rel="external">Apple</a>官方的描述，可以大致分为以下三类：</p>
<ol>
<li>官方给出的使用最广泛的场景，对一个已经存在的类（不管实现已知还是未知）进行增加方法的扩展，而不去子类化。扩展出来的类均可以被子类和原始类来使用。</li>
<li>把代码量的类中的方法划分成多个Category文件。</li>
<li>声明私有方法。</li>
</ol>
<p>在日常使用的过程中，我们通常使用的是一种方法，因为其封装的便利性，使得其应用非常的广泛。我们使用Category的基本原则：</p>
<blockquote>
<p>“The answer is don’t do that. Only add methods,don’t try to replace or otherwise.It’s hard to understand for people reading your code”</p>
</blockquote>
<p>如果说你在使用的时候发现你试图在Category中去overwrite父类的方法，虽然是可以这么做的，但是不推荐。因为重写之后，在使用方法的时候会优先选择Category中的方法实现，导致原来的方法不能使用。如果出现了这种情况，那么一定是你使用场景出现大的错误，要尝试继承或者其他的封装方法。</p>
<h2 id="u6CE8_u610F"><a href="#u6CE8_u610F" class="headerlink" title="注意"></a>注意</h2><ul>
<li><p>不需要实现所有的方法<br>在我们平时的使用中，在Category中声明的方法并不需要都实现，关键在于你会不会调用方法。</p>
</li>
<li><p>命名<br>开发者在项目的过程中，常常会出现积累了自己Category的情况。当使用三方库的时候，有可能出现Category重名的问题，所以建议大家在创建Category的时候，加上自己特有的prefix。可以在最初使用的时候统一命名为+xxTools，等到Category方法越来越多的时候在进行根据功能划分的Category拆分，当然同时也要加上prefix，避免重名。</p>
</li>
<li><p>属性<br>大家都会说Category中不能自定义属性。这种说法其实是不正确的，在Category中可以声明property，也同样会实现setter和getter方法，但是对于属性的实现是不行的。想要进行弥补，就只能使用Associated Objects来实现。我们将在该系列的下一篇<a href="http://yeziahehe.com/2016/01/06/Objective-C%E5%B0%81%E8%A3%85%E6%8A%80%E5%B7%A7%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%B8%8E%E2%80%9C%E9%AD%94%E9%AC%BC%E7%9A%84%E4%BA%A4%E6%98%93%E2%80%9D%20--%20Associated%20Objects/">博客</a>中来详细展开。</p>
</li>
</ul>
<h2 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h2><p>大家对于Category的封装，可以参考<a href="https://github.com/ibireme" target="_blank" rel="external">Yaoyuan</a>大神的<a href="https://github.com/ibireme/YYCategories" target="_blank" rel="external">YYCategory</a>，直接拿来就能用。对他为开源做出的贡献表示感谢。</p>
<h1 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h1><p>通过上述的展开，我们可以大概总结一下。对于需要重写的父类的方法，或者需要对实例属性进行操作的时候，我们需要选择继承，继承通常应在UIKit的对象中。对于现有类方法的扩展，或者对于Foundation中对象的封装，通常首先考虑使用Category。<br>最后，本篇文章回答了第一次问题，其他的两个问题，将在下面两篇博客中来展开。</p>
<blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt=""><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2016/01/05/Objective-C_package_skill(1)：Category_and_inherit/">http://yeziahehe.com/2016/01/05/Objective-C_package_skill(1)：Category_and_inherit/</a></blockquote>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p>有经验的工程师在经历过一些项目之后，会慢慢的去考]]>
    </summary>
    
      <category term="iOS" scheme="http://yeziahehe.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://yeziahehe.com/tags/Objective-C/"/>
    
      <category term="封装" scheme="http://yeziahehe.com/tags/%E5%B0%81%E8%A3%85/"/>
    
      <category term="继承" scheme="http://yeziahehe.com/tags/%E7%BB%A7%E6%89%BF/"/>
    
      <category term="Category" scheme="http://yeziahehe.com/tags/Category/"/>
    
      <category term="技术" scheme="http://yeziahehe.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Bye 2015，Hi 2016]]></title>
    <link href="http://yeziahehe.com/2016/01/04/Bye%202015%EF%BC%8CHi%202016/"/>
    <id>http://yeziahehe.com/2016/01/04/Bye 2015，Hi 2016/</id>
    <published>2016-01-04T07:25:09.000Z</published>
    <updated>2016-08-07T20:30:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p>2015年做了好多从来没有想过的事情，感觉自己慢慢的开始长大，开始离开父母的庇护，一个人去体验这个世界。</p>
<h1 id="u5173_u4E8E_u5B66_u4E1A"><a href="#u5173_u4E8E_u5B66_u4E1A" class="headerlink" title="关于学业"></a>关于学业</h1><p>2015年下半年，我大四了，临近毕业，正好对四年大学的生活做一个总结。<br>我记得我刚刚进大学的时候一心就是要参与学校的组织里面去，希望能够慢慢的做个有影响力的人。我今年最大的感悟，发现彦祖和百万都再利用自己的影响力，去给整个移动开发生态圈营造良好的学习和分享氛围。我很感谢他们，也很感谢这个信息爆炸的时代。继续说我，当初刚刚进大学的想法，因为我摔了脚，无奈做了手术，在家休养了很久。等我再回学校的时候，发现我和学生组织已经脱节了，他们玩的很开心，彼此都熟悉了。我也庆幸，我卧床休养的那几个月，我把我的windows系统删了，装了个OS X系统，捣鼓了iOS的开发。这么说来，我从2012年的年底就开始接触移动开发了。<br>大二大三的时候，我慢慢离开了学生组织，辞去了班长，加入了实验室，正式开始做iOS的开发。说实话，我承认自己的学校确实大氛围并没有那么好，江苏某发展很好的城市的唯一一所211，我自己一个人捣鼓，那一年多的时间，技术进步的很慢。但是没有比较就不知道人外有人、天外有天。大二的暑假我没回家，在实验室捣鼓了一暑假，给学校做了个app。大三暑假我也没有回家，去了一家很小的公司实习，学到了不少。<br>大四了，我也要毕业，我感觉大学这四年，我的学业我没有花心思，我的技术投入了很多精力，但是却也没有成为大牛。总结下来，其实还是觉得自己四年书读的太少，对于问题的思考也没有那么积极。</p>
<h1 id="u5173_u4E8E_u521B_u4E1A"><a href="#u5173_u4E8E_u521B_u4E1A" class="headerlink" title="关于创业"></a>关于创业</h1><p>创业，这个字眼本来根本不会出现在我人生的字典轨迹里面。我大四的时候准备出国，在考完GRE之后，还是跟我的两个室友一拍即合，成立了公司。<br>我觉得对于我们来说，根本不能用创业这个词来描述我们所做的工作，应该用 <strong>生存</strong> 这个词来描述。<br>年轻气盛，什么都不怕，我们从今年的4月份开始准备公司注册，到成立公司，到现在运营，回头看看真的像做梦一样。<br>我的两个室友，一个做Android开发，一个做服务端开发，我们就是铁三角组合。最初，其实想法很简单，搞一个项目，拿到融资，当上CEO，赢取白富美，走上人生巅峰。后来发现，现实不是这样，资本寒冬来了之后，融资变得异常困难。我们开始接外包，为了生存下去，7月份到11月份，我自己从公司拿了4k做生活费。 <strong>等你正真开始走进社会的时候，你才知道，社会比你想象的要残酷的多。</strong> 我们经历很多奇奇怪怪的客户，要求苛刻的客户，而项目的款项也并没有如期的收回来，公司的处境越来越难。11月被迫，解散了其他的同事，只剩下我们三个人。<br>今年，我觉得我从社会里面学到了太多太多，我也从一个学生思维转变到了社会思维，我没有后悔没出国，也没有后悔这几个月艰苦的日子，我觉得这是我这辈子的财富。<br>我也希望，所有创业的大学生小伙伴，都能够成功，但是大家如果没有好的idea，没有足够运营经验的人帮助，大家轻易不要去尝试。 <strong>路还长，等我们装备精良，再出发。</strong></p>
<h1 id="u5173_u4E8E_u804C_u4E1A_u751F_u6DAF"><a href="#u5173_u4E8E_u804C_u4E1A_u751F_u6DAF" class="headerlink" title="关于职业生涯"></a>关于职业生涯</h1><p>我对于职业生涯，其实想的很简单， <strong>我想去看更大的世界。</strong> 我创过业，自己折腾了很久的技术，我也看到影响力大的人在传播技术、分享技术。我想加入他们，与他们一起去看更大的世界。<br>对于即将要毕业的我，只剩下明年的春招，我觉得我该去试试，离开我自己折腾这么久的地方，去远方看看。</p>
<h1 id="u5173_u4E8E_u751F_u6D3B_u548C_u672A_u6765"><a href="#u5173_u4E8E_u751F_u6D3B_u548C_u672A_u6765" class="headerlink" title="关于生活和未来"></a>关于生活和未来</h1><p>我看完了很多人的总结，我发现我根本不热爱生活，我的生活总是那么的单调，没有生活情趣。生活中的很多细节，会让一个人慢慢的热爱上生活，热爱上工作，也变得积极。<br>今年在自己的城市买了房子，但是应该会出现几年，看看更大的世界，最后再回到这里。希望未来，越来越好。<br>关于未来，我希望：</p>
<ul>
<li><strong>读书，不再全部是技术类的书，读点其他方面的书，争取写出读书笔记，今年目标10本。</strong></li>
<li><strong>健身，我办了健身卡，却一直放在包里，今年努力健身，练出好的身材，每周健身2次。</strong></li>
<li><strong>摄影，我开始慢慢的喜欢上欣赏美的东西，今年希望自己能赚到钱买到入门级的单反，学好摄影。</strong></li>
<li><strong>练字，下半年毕业后，准备重拾丢了多年的楷书。</strong></li>
<li><strong>设备，2012mid的MBP要换了，还是努力挣钱，或者称手的家伙。</strong></li>
<li><strong>工作，我心里有了目标，希望今年加油。</strong></li>
<li><strong>技术，做有影响力的事情，热爱开源，多认识大牛。</strong></li>
</ul>
<blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt=""><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2016/01/04/Bye">http://yeziahehe.com/2016/01/04/Bye</a> 2015，Hi 2016/</blockquote>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p>2015年做了好多从来没有想过的事情，感觉自己慢]]>
    </summary>
    
      <category term="总结" scheme="http://yeziahehe.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="2015" scheme="http://yeziahehe.com/tags/2015/"/>
    
      <category term="随想" scheme="http://yeziahehe.com/categories/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS开发工程师职业图谱]]></title>
    <link href="http://yeziahehe.com/2016/01/04/iOS_dev_professional_map/"/>
    <id>http://yeziahehe.com/2016/01/04/iOS_dev_professional_map/</id>
    <published>2016-01-04T03:11:07.000Z</published>
    <updated>2016-09-02T03:04:54.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近极客学院发起了<a href="https://github.com/jikexueyuanwiki/skillmap" target="_blank" rel="external">IT技能图谱</a>，针对<a href="https://github.com/jikexueyuanwiki/skillmap/blob/master/iOS.md" target="_blank" rel="external">iOS 开发工程师</a>的职业图谱，我决定做个技能树的完成度评估。</p>
<h1 id="u8BF4_u660E"><a href="#u8BF4_u660E" class="headerlink" title="说明"></a>说明</h1><ul>
<li>难度等级：R1-R5, 对应关系：零基础(R1)、简单(R2)、一般(R3)、困难(R4)、非常困难(R5)</li>
<li>达到程度：P1-P5, 对应关系：了解(P1)、熟悉(P2)、掌握(P3)、精通(P4)、专家(P5)</li>
<li><del>删除线</del>代表该项基本完成，未完成的部分准备补上进度百分比。</li>
</ul>
<h1 id="u804C_u4E1A_u56FE_u8C31"><a href="#u804C_u4E1A_u56FE_u8C31" class="headerlink" title="职业图谱"></a>职业图谱</h1><ul>
<li>通用基础(R3,P2)<ul>
<li>理论基础(R4,P3)<ul>
<li>数据结构(R4,P3)</li>
<li>算法(R4,P3)</li>
</ul>
</li>
<li>编程语言(R3,P2)<ul>
<li>Objective-C(R3,P3)</li>
<li>Swift(R3,P2)</li>
</ul>
</li>
</ul>
</li>
<li>Objective-C基础(R3,P3)<ul>
<li>Objective-C基本语法(R2,P4)<ul>
<li><del>变量(R2,P4)</del></li>
<li><del>常量(R2,P4)</del></li>
<li><del>数据类型(R2,P4)</del></li>
<li><del>运算符和表达式(R2,P4)</del></li>
<li><del>判断(R2,P4)</del></li>
<li><del>循环(R2,P4)</del></li>
<li><a href="https://github.com/QianKaiLu/Objective-C-Coding-Guidelines-In-Chinese" target="_blank" rel="external">Objective-C编码规范</a>(R2,P4)</li>
</ul>
</li>
<li>Objective-C语法进阶(R3,P3)<ul>
<li><del>类和对象(R3,P3)</del></li>
<li><del>属性和变量(R3,P3)</del></li>
<li><del>继承(R3,P3)</del></li>
<li><del>多态(R3,P3)</del></li>
<li>动态绑定(R3,P3)</li>
<li>block块(R3,P3)</li>
<li>异常处理(R3,P3)</li>
<li><del>Category类别(R3,P3)</del></li>
<li>Extension扩展(R3,P3)</li>
<li><del>Protocol协议 (R3,P3)</del></li>
</ul>
</li>
<li>Objective-C高级语法(R4,P2)<ul>
<li>KVC(R4,P2)</li>
<li>KVO(R4,P2)</li>
<li><del>Notification(R4,P2)</del></li>
<li><del>引用计数与ARC(R4,P2)</del></li>
<li>内存管理(R4,P4)</li>
<li>多线程(R4,P3)</li>
</ul>
</li>
<li>Objective-C Foundation框架(R3,P3)<ul>
<li><del>NSNumber(R3,P3)</del></li>
<li><del>NSString(R3,P4)</del></li>
<li><del>NSArray(R3,P4)</del></li>
<li><del>NSDictionary(R3,P4)</del></li>
<li><del>NSSet(R3,P2)</del></li>
</ul>
</li>
</ul>
</li>
<li>Swift基础(R2,P2)<ul>
<li>Swift基本语法(R2,P2)<ul>
<li>变量(R2,P2)</li>
<li>常量(R2,P2)</li>
<li>数据类型(R2,P2)</li>
<li>判断(R2,P2)</li>
<li>循环(R2,P2)</li>
<li>Swift编码规范(R2,P2)</li>
</ul>
</li>
<li>Swift语法进阶(R3,P2)<ul>
<li>Swift字符串(R3,P2)</li>
<li>数组(R3,P2)</li>
<li>字典(R3,P2)</li>
<li>元组(R3,P2)</li>
<li>函数(R3,P2)</li>
<li>可选型optionals(R3,P2)</li>
<li>枚举(R3,P2)</li>
<li>闭包 (R3,P2)</li>
</ul>
</li>
<li>Swift高级语法(R4,P1)<ul>
<li>Swift和Objective-C混合编程(R3,P1)</li>
<li>Swift源码(R5,P1)</li>
</ul>
</li>
</ul>
</li>
<li>iOS开发基础(R2,P3)<ul>
<li>iOS基础(R2,P3)<ul>
<li>iOS生命周期(R3,P3)</li>
<li>事件与消息(R3,P3)</li>
<li><del>模拟器(R2,P2)</del></li>
<li><del>真机调试(R2,P2)</del></li>
</ul>
</li>
<li>UI控件(R2,P4)<ul>
<li><del>Button(R2,P4)</del></li>
<li><del>Label(R2,P4)</del></li>
<li><del>ImageView(R2,P4)</del></li>
<li><del>ScrollView(R2,P4)</del></li>
<li><del>TableView(R4,P4)</del></li>
<li><del>CollectionView(R4,P3)</del></li>
<li><del>自定义控件(R4,P2)</del></li>
</ul>
</li>
<li>界面布局(R3,P3)<ul>
<li>代码布局(R3,P3)</li>
<li><del>nib/xib文件(R2,P3)</del></li>
<li>storyboard(R2,P3)</li>
</ul>
</li>
</ul>
</li>
<li>iOS开发进阶(R3,P3)<ul>
<li>动画效果(R3,P2)<ul>
<li>UIView动画(R3,P2)</li>
<li>Core Animation(R3,P2)</li>
<li>第三方动画库pop(R3,P1)</li>
</ul>
</li>
<li>多线程(R4,P4)<ul>
<li>NSThread(R4,P3)</li>
<li>NSOperationQueue(R4,P4)</li>
<li>GCD(R3,P4)   </li>
</ul>
</li>
<li>数据存储(R3,P4)<ul>
<li><del>NSUserDefault(R3,P4)</del></li>
<li>SQLite(R3,P2)</li>
<li>CoreData(R3,P4)</li>
</ul>
</li>
<li>数据处理(R3,P3)<ul>
<li><del>Model(R4,P3)</del></li>
<li>XML解析(R3,P4)</li>
<li><del>JSON解析(R3,P4)</del></li>
</ul>
</li>
<li>物理特性(R3,P1)<ul>
<li><del>各类传感器(R3,P1)</del></li>
<li><del>摄像头(R3,P1)</del></li>
<li>指纹识别(R3,P1)</li>
<li>Force Touch(R3,P1)</li>
</ul>
</li>
<li>网络与通信(R3,P3)<ul>
<li><del>Http(R3,P4)</del></li>
<li>Socket(R3,P2)</li>
<li>SOAP(R3,P2)</li>
<li><del>抓包(R4,P1)</del></li>
</ul>
</li>
<li>屏幕适配(R3,P3)<ul>
<li>代码适配(R3,P4)</li>
<li><del>Autoresizing(R2,P4)</del></li>
<li><del>AutoLayout(R3,P3)</del></li>
<li>Size Classes(R4,P2)    </li>
</ul>
</li>
<li>其他(R3,P2)<ul>
<li>多点触控(R3,P1)</li>
<li><del>手势识别(R3,P1)</del></li>
<li>传感器(R3,P1)</li>
<li><del>定位(R3,P3)</del></li>
<li>电源管理(R3,P1)</li>
<li><del>消息推送(R3,P3)</del>  </li>
</ul>
</li>
</ul>
</li>
<li>iOS高级开发(R4,P2)<ul>
<li>iOS架构(R4，P2)<ul>
<li><del>MVC(R3,P2)</del></li>
<li><del>MVVM(R4,P1)</del></li>
<li>设计模式(R5,P2)</li>
</ul>
</li>
<li>第三方框架(R3,P2)<ul>
<li><del>AFNetworking(R3,P3)</del></li>
<li><del>SDWebImage(R3,P2)</del></li>
<li><del>MBProgressHUD(R3,P2)</del></li>
<li>Masonry(R3,P1)     </li>
</ul>
</li>
<li>第三方SDK(R3,P2)<ul>
<li><del>分享(R3,P3)</del></li>
<li>第三方登录(R4,P2)</li>
<li><del>短信验证码(R3,P3)</del>  </li>
<li>其他各类API(R3,P2)</li>
</ul>
</li>
</ul>
</li>
<li>开发效率(R3,P3)<ul>
<li>IDE(R2,P4)<ul>
<li>Xcode(R2,P4)</li>
</ul>
</li>
<li>插件(R2,P1)<ul>
<li><del>Alcatraz(R2,P1)</del>   </li>
</ul>
</li>
<li>包管理(R2,P3)<ul>
<li><del>Cocoapods</del>   </li>
</ul>
</li>
<li>版本控制(R2,P3)<ul>
<li><del>Git(R2,P3)</del></li>
<li><del>SVN(R2,P3)</del></li>
</ul>
</li>
<li>应用内测与分发(R2,P1)<ul>
<li>Pre.im(R2,P1)</li>
<li><del>蒲公英(R2,P1)</del></li>
</ul>
</li>
<li>后台服务(R2,P1)<ul>
<li><a href="http://www.bmob.cn/" target="_blank" rel="external">Bmob</a>(R2,P1)</li>
<li><a href="http://www.parse.com/" target="_blank" rel="external">Parse</a> (R2,P1)</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt=""><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2016/01/04/iOS_dev_professional_map/">http://yeziahehe.com/2016/01/04/iOS_dev_professional_map/</a></blockquote>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近极客学院发起了<a href="https:]]>
    </summary>
    
      <category term="iOS" scheme="http://yeziahehe.com/tags/iOS/"/>
    
      <category term="skillmap" scheme="http://yeziahehe.com/tags/skillmap/"/>
    
      <category term="技术" scheme="http://yeziahehe.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅谈iOS中Library和Framework]]></title>
    <link href="http://yeziahehe.com/2015/12/30/talk_iOS_Library_and_Framework/"/>
    <id>http://yeziahehe.com/2015/12/30/talk_iOS_Library_and_Framework/</id>
    <published>2015-12-30T02:40:25.000Z</published>
    <updated>2016-09-02T03:05:14.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p>有关于库的出现场景，其实很简单的回答就是，不愿意把实现的源码暴露给其他人。虽然我是脑残的开源爱好者，但是总有些场景下，有这样的需求，比如外包公司的框架，比如我这次写NativeScript，需要自己将三方库打包然后使用在js中调用（当然后来我看到支持CocoaPods的时候，喷了一口老血）。不过这个是客观的一些原因，还有一些有想法的程序员，为了减少编译的时间，也会选择将改动不大的代码进行打包。打包好的代码是编译完成的二进制文件，在项目进行编译的时候链接上，确实一定程度的减少编译时间。</p>
<h1 id="u5E93_u7684_u672C_u8D28"><a href="#u5E93_u7684_u672C_u8D28" class="headerlink" title="库的本质"></a>库的本质</h1><p>库的本质，我觉得非常好理解。我们首先要知道对于所有的库，都是进行编译的，而编译生成的其实是一段二进制代码。所以我们可以给库下个定义：</p>
<blockquote>
<p>提供头文件的编译好的二进制代码。</p>
</blockquote>
<p>对于库的链接，分为了动态链接和静态链接，这也就产生了iOS中的静态库和动态库。</p>
<h1 id="u9759_u6001_u5E93_u548C_u52A8_u6001_u5E93"><a href="#u9759_u6001_u5E93_u548C_u52A8_u6001_u5E93" class="headerlink" title="静态库和动态库"></a>静态库和动态库</h1><p>静态库（Windows 下的 .lib，Linux 和 Mac 下的 .a）。<br>动态库（Windows 下的 .dll，Linux 下的 .so，Mac 下的 .dylib）。</p>
<p>和所有平台所理解静态链接库、动态链接库一样，静态和动态都是相对于编译和运行来讲的：静态库在编译的时候就会被拷贝到目标程序中，运行的时候就不会在改变了；动态库在编译的时候是不会拷贝到目标程序中，在运行的时候会将库加载进来。</p>
<h2 id="u7F16_u8BD1_u548C_u8FD0_u884C"><a href="#u7F16_u8BD1_u548C_u8FD0_u884C" class="headerlink" title="编译和运行"></a>编译和运行</h2><p>区分下编译和运行的概念。在Xcode中我们进行CMD+R的时候其实做了很多的步骤，编译和运行都包括在其中。</p>
<p>编译：如果我们自己打包的时候，使用的是CMD+B的命令，其实是调用了LLVM编译器，进行编译，编程计算机能识别的二进制码。<br>运行：将编译生成的文件链接为可执行文件并进行运行。</p>
<p>静态库就是在目标程序编译的时候已经存在了编译好了的二进制代码，所以说目标程序编译的时候不需要对这段代码进行改变，而且还减少了编译时间。<br>动态库就是在目标程序编译的时候不去链接，而是创建了引用，在运行的时候，进行对动态库的链接和编译。</p>
<h2 id="u4F18_u7F3A_u70B9"><a href="#u4F18_u7F3A_u70B9" class="headerlink" title="优缺点"></a>优缺点</h2><p>静态库的好处很明显，编译完成之后，库文件实际上就没有作用了。目标程序没有外部依赖，直接就可以运行。当然其缺点也很明显，就是会使用目标程序的体积增大。</p>
<p>动态库的优点，不需要拷贝到目标程序中，不会影响目标程序的体积，而且同一份库可以被多个程序使用（因为这个原因，动态库也被称作共享库）。同时，编译时才载入的特性，也可以让我们随时对库进行替换，而不需要重新编译代码，这样就可以实现动态更新。动态库带来的问题主要是，动态载入会带来一部分性能损失，使用动态库也会使得程序依赖于外部环境。如果环境缺少动态库或者库的版本不正确，就会导致程序无法运行。</p>
<h1 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h1><p>Framework是Mac OS/iOS平台特有的一种打包方式，将编译生成的二进制文件、头文件、资源文件统一打包。可以包含如下的东西：</p>
<ul>
<li>共享库</li>
<li>描述API的头文件</li>
<li>文档</li>
<li>资源文件（UI，Assets，配置文件）</li>
</ul>
<p>在iOS 8之前我们Framework其实就是静态库，原因很简单，之前Apple官方不支持动态打包，我们只能使用官方的UIKit或者Foundation等Framework。从iOS 8之后苹果开放了对动态Framework的支持，这应该是苹果为支持 Extension 这一特性而做出的选择（Extension 和 App 是两个分开的可执行文件，它们之间共享代码，所以需要 Framework 支持）。不过我们这个和系统还是有区别，系统的 Framework 不需要拷贝到目标程序中，我们自己做出来的 Framework 哪怕是动态的，最后也还是要拷贝到 App 中，因此苹果又把这种 Framework 称为Embedded Framework。这个时候所谓的动态库其实意义就是升级版的静态库，因为动态库使用的前提是项目在发布前添加到项目中，这和我们所谓的插件（即插即用，随时在自己的服务器上下载一个动态库运行，而不需要重新打包，我们可以选择在需要的时候再加载动态库）完全是两码事。当然我们可以通过方法去实现Framework的动态更新，这里不做赘述。</p>
<h2 id="u521B_u5EFA"><a href="#u521B_u5EFA" class="headerlink" title="创建"></a>创建</h2><p>应该说现在创建一个Framework非常的方便，我们基本上不需要很简单的就能够制作一个Framework。<br>首先我们新建一个Framwork的项目<br><img src="http://7xkvt5.com1.z0.glb.clouddn.com/coryphaei%2Fcreate_framework.png" alt="新建项目"></p>
<p>然后把我们需要创建的文件加入其中，注意这边添加的是Swift的文件，因为Swift中是没有.h和.m的，所以会默认会帮你生成一个xxx-Swift.h的头文件，其中是所有public属性和方法都暴露了出来。<br><img src="http://7xkvt5.com1.z0.glb.clouddn.com/coryphaei%2Fadd_file.png" alt="添加文件"></p>
<h2 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h2><p>接下来应该是有个配置的过程，这边需要详细讲下这些变量是什么意思。</p>
<h3 id="arm"><a href="#arm" class="headerlink" title="arm"></a>arm</h3><p>arm代表的是使用的设备的处理器的型号，大致分为以下几种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">arm64 = iPhone 5s, iPad Air, Retina iPad Mini</div><div class="line">armv7s = iPhone 5, iPhone 5c, iPad 4</div><div class="line">armv7  = iPhone 3GS, iPhone 4, iPhone 4S, iPod 3G/4G/5G, iPad, iPad 2, iPad 3, iPad Mini   </div><div class="line">i386 = 32 bit simulator</div><div class="line">x86_64 = 64 bit simulator</div></pre></td></tr></table></figure></p>
<h3 id="u51E0_u4E2A_u8BBE_u7F6E"><a href="#u51E0_u4E2A_u8BBE_u7F6E" class="headerlink" title="几个设置"></a>几个设置</h3><p>Architectures：该编译选项指定了工程将被编译成支持哪些指令集，支持指令集是通过编译生成对应的二进制数据包实现的，如果支持的指令集数目有多个，就会编译出包含多个指令集代码的数据包，造成最终编译的包很大。<br>Valid Architectures：该编译项指定可能支持的指令集。<br>最后生成的支持工程的指令集应该是上面两个所产生的交集。</p>
<p>Build Active Architecture Only：该编译项用于设置是否只编译当前使用的设备对应的arm指令集。<br>当这个选项设置为YES的时候，不管Architectures和Valid Architectures设置为什么，最后都只会输出支持当前使用设备对应的arm指令集。<br>通常debug选择YES，release选择NO。</p>
<p>有关于指令集的选择，因为指令集有着向下兼容的特性，所以说为了减少包的大小，我们通常选择只支持armv7，在armv7s和arm64的机器上同样可以使用，当然性能有部分损失，可以忽略不计。<br><img src="http://7xkvt5.com1.z0.glb.clouddn.com/coryphaei%2Fconfig.png" alt="config"></p>
<h2 id="u7F16_u8BD1"><a href="#u7F16_u8BD1" class="headerlink" title="编译"></a>编译</h2><p>有关于编译，一共有两种方式：release和debug。<br>可以手动设置run的方式。<br><img src="http://7xkvt5.com1.z0.glb.clouddn.com/coryphaei%2Fmodify_run.png" alt="modify_run"><br><img src="http://7xkvt5.com1.z0.glb.clouddn.com/coryphaei%2Fmodify_run_release.png" alt="modify_run_release"></p>
<h2 id="u5B8C_u6210"><a href="#u5B8C_u6210" class="headerlink" title="完成"></a>完成</h2><p>Products里面生成了Framework，找到Framework的位置。<br><img src="http://7xkvt5.com1.z0.glb.clouddn.com/coryphaei%2Fframework_finish.png" alt="Fframework_finish"></p>
<h2 id="u5408_u5E76"><a href="#u5408_u5E76" class="headerlink" title="合并"></a>合并</h2><p>接下来应该是需要把模拟器和真机的Framework进行合并，网上应该有脚本，我是直接实用命令行的方式。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lipo -create Debug-iphoneos/SocketIO.framework/SocketIO Debug-iphonesimulator/SocketIO.framework/SocketIO -output SocketIOLib</div></pre></td></tr></table></figure></p>
<p>合并完成后进行查看，可以看到支持的指令集。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lipo -info ~/Library/Developer/Xcode/DerivedData/SocketIO-bwzuuvegsamvhtbdwasganalbadg/Build/Products/Debug-iphoneos/SocketIO.framework/SocketIO</div></pre></td></tr></table></figure></p>
<blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt=""><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2015/12/30/talk_iOS_Library_and_Framework/">http://yeziahehe.com/2015/12/30/talk_iOS_Library_and_Framework/</a></blockquote>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p>有关于库的出现场景，其实很简单的回答就是，不愿意]]>
    </summary>
    
      <category term="iOS" scheme="http://yeziahehe.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://yeziahehe.com/tags/Swift/"/>
    
      <category term="Objective-C" scheme="http://yeziahehe.com/tags/Objective-C/"/>
    
      <category term="Framework" scheme="http://yeziahehe.com/tags/Framework/"/>
    
      <category term="技术" scheme="http://yeziahehe.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Objective-C新纪元--ReactiveCocoa框架]]></title>
    <link href="http://yeziahehe.com/2015/12/15/Objective-C_epoch--ReactiveCocoa_framwork/"/>
    <id>http://yeziahehe.com/2015/12/15/Objective-C_epoch--ReactiveCocoa_framwork/</id>
    <published>2015-12-15T06:56:46.000Z</published>
    <updated>2016-09-02T03:08:16.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>很久之前我就准备写有关于ReactiveCocoa的文章，前面林林总总写过几篇，但是都是简单的讲述，并没有深刻的去总结这个技术。根本的原因在于这个技术确实很难入门，但是ReactiveCocoa的出现确实可以给iOS带来很多新的思考和实现，ReactiveCocoa更加被Mattt Thompson大神称为开启一个新Objective-C纪元。另外提醒大家，我看到的优秀的讲ReactiveCocoa的文章篇幅都很长，其实大家都在简洁的语言来讲，我的这边文章应该写完也是长篇幅，希望大家可以耐心的看完。</p>
<h1 id="u51FD_u6570_u54CD_u5E94_u5F0F_u7F16_u7A0B"><a href="#u51FD_u6570_u54CD_u5E94_u5F0F_u7F16_u7A0B" class="headerlink" title="函数响应式编程"></a>函数响应式编程</h1><p>ReactiveCocoa的基本思想就是<code>函数响应式编程（Function Reactive Programming，以下简称FRP）</code>。FRP是一种响应变化的编程范式。我们通常会拿一个经典的例子来解释概念。</p>
<h2 id="u7406_u5FF5"><a href="#u7406_u5FF5" class="headerlink" title="理念"></a>理念</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a = <span class="number">2</span></div><div class="line">b = <span class="number">2</span></div><div class="line">c = a + b<span class="comment">// c = 4</span></div><div class="line"></div><div class="line">b = <span class="number">4</span></div><div class="line"><span class="comment">// 现在c的值是多少？</span></div></pre></td></tr></table></figure>
<p>上面的问题，正常人一眼就能看出答案，因为我们<code>响应</code>了<code>b = 2</code>这个值的变化，所以说<code>c</code>的值会随着<code>b</code>的值的改变而改变。FRP就是使用这样的基本原理，所以称之为<code>响应式编程</code>。</p>
<h2 id="u5982_u4F55_u5B9E_u73B0"><a href="#u5982_u4F55_u5B9E_u73B0" class="headerlink" title="如何实现"></a>如何实现</h2><p>FRP提供了<code>信号（Signal）</code>机制来实现这样的效果，通过信号来记录值的变化。通过信号的组合，从而不再去监听值的变化，甚至是事件的变化。在上述例子中加入了signal的图解：<br><img src="http://7xp57v.com1.z0.glb.clouddn.com/coryphaei/FRP_signal.png" alt="FRP_signal"></p>
<h2 id="ReactiveCocoa_u4F5C_u8005_u5BF9_u4E8EFRP_u7684_u89E3_u91CA"><a href="#ReactiveCocoa_u4F5C_u8005_u5BF9_u4E8EFRP_u7684_u89E3_u91CA" class="headerlink" title="ReactiveCocoa作者对于FRP的解释"></a>ReactiveCocoa作者对于FRP的解释</h2><p><a href="http://blog.maybeapps.com/post/42894317939/input-and-output" target="_blank" rel="external">Josh Abernathy这样解释它：</a></p>
<blockquote>
<p>程序接收输入产生输出。输出就是对输入做了一些事的结果。输入，转换，输出，完成。<br>输入是应用动作的全部来源。点击、键盘事件、定时器事件、GPS时间、网络请求响应都算是输入。这些事件被传递到应用中，应用将他们以某种方式混合，产生了结果：就是输出。<br>输出通常会改变应用的UI。开关状态变化、列表有了新的元素都是UI变化。也有可能让磁盘上某个文件产生变化，或者产生一个API请求，这都是应用的输出。<br>但不像传统的输入输出设计，应用的输入输出可以产生很多次。应用打开后，不只是一个简单的 输入→工作→输出 就构成了一个生命周期。应用经常有大量的输入并基于这些输入产生输出。</p>
</blockquote>
<h2 id="u8BDD_u5916"><a href="#u8BDD_u5916" class="headerlink" title="话外"></a>话外</h2><p>关于ReactiveCocoa的灵感来源，我们可以看到官方README中提到了<code>ReactiveCocoa深受Microsoft&#39;s Reactive Extension的思想，并基于Reactive Extension（Rx）</code>。但是官方列举了很多ReactiveCocoa有别于Rx的地方，有兴趣的可以去了解下。</p>
<h1 id="ReactiveCocoa"><a href="#ReactiveCocoa" class="headerlink" title="ReactiveCocoa"></a>ReactiveCocoa</h1><p><a href="http://reactivecocoa.io/" target="_blank" rel="external">ReactiveCocoa</a> is a framework developed by <a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">GitHub</a> to support functional reactive programming on iOS and OS X.</p>
<h2 id="u8D77_u56E0"><a href="#u8D77_u56E0" class="headerlink" title="起因"></a>起因</h2><p>作为一个移动开发者，应用中经常有大量的输入，大部分的代码都用来响应这些输出并且基于这些输入来产生输出。我们需要响应的事件非常多：按钮点击事件（target-action）、网络消息回调事件（Block or delegate）、属性变化事件（KVO）、通知事件（NSNotification）等，而这边响应事件在代码中的表现形式却并不统一。为了定义一个标准统一的事件处理接口，并且通过定义的接口来进行组合使用，ReactiveCocoa出现了。</p>
<h2 id="u57FA_u672C_u601D_u60F3"><a href="#u57FA_u672C_u601D_u60F3" class="headerlink" title="基本思想"></a>基本思想</h2><p>我们GitHub主页上看到，官方这样给出了概念：</p>
<blockquote>
<p>ReactiveCocoa (RAC)是采用FRP的一个Cocoa framework。RAC提供了API用来组合、转换一直变化的数据流。</p>
</blockquote>
<p>ReactiveCocoa采用FRP思想，<code>信号</code>则是这个思想的精髓所在，灵魂所在。在ReactiveCocoa简称是RAC，所有的类都以<code>RAC</code>开头，所以说ReactiveCocoa中的信号就用<code>RACSignal</code>类来表示，用来展示<code>事件流</code>的变化，并且可以通过链接、过滤、组合等方式来进行处理。</p>
<blockquote>
<p>引用我在很多博客中看到的一段话，但是我对其做了改动，加入了桶的概念：<br>可以把信号(signal)想象成水龙头，只不过里面不是水，而是玻璃球(stream of value)，直径跟水管的内径一样，这样就能保证玻璃球是依次排列，不会出现并排的情况(数据都是线性处理的，不会出现并发情况)。只要你打开水龙头的开关，就会有玻璃球出来。但是，并不是所有的玻璃球都能被使用，除非有了桶(subscriber)来接收掉下来的玻璃球，这样才能运往需要的地方。这样有新的玻璃球进来，有桶在监听，就会自动传送给接收者。可以在水龙头上加一个过滤嘴(filter)，不符合的不让通过，也可以加一个改动装置，把球改变成符合自己的需求(map)。也可以把多个水龙头合并成一个新的水龙头(combineLatest:reduce:)，这样只要其中的一个水龙头有玻璃球出来，这个新合并的水龙头就会得到这个球。</p>
</blockquote>
<h2 id="u601D_u8003"><a href="#u601D_u8003" class="headerlink" title="思考"></a>思考</h2><p>通过上述对其的了解，总结ReactiveCocoa带来的影响。</p>
<ul>
<li>定义标准的事件处理接口</li>
<li>解决了状态过多依赖的问题</li>
</ul>
<p>PS：关于巧哥说的给Controller瘦身的问题，我认为这个是MVVM框架所带来的影响，ReactiveCocoa只是很好的配合了MVVM。因此我并没有把这一点归纳在内。</p>
<h1 id="u5F00_u59CB"><a href="#u5F00_u59CB" class="headerlink" title="开始"></a>开始</h1><p>进入正轨，开始介绍ReactiveCocoa的机制和常用方法。</p>
<h2 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h2><p>推荐大家用<a href="http://code4app.com/article/cocoapods-install-usage" target="_blank" rel="external">CocoaPods</a>进行安装，这么好的工具肯定要掌握的。<br><img src="http://7xp57v.com1.z0.glb.clouddn.com/coryphaei/cocoapods.png" alt="CocoaPods"><br>目前4.0的alpha版本正在开发，建议大家先使用发布的版本。如果你用swift来写可以用3.0，我是用的Objective，所以用的2.5版本，Podfile:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">platform :ios, &apos;8.0&apos;</div><div class="line">pod &apos;ReactiveCocoa&apos;, &apos;~&gt; 2.5&apos;</div></pre></td></tr></table></figure></p>
<h2 id="RACStreams"><a href="#RACStreams" class="headerlink" title="RACStreams"></a>RACStreams</h2><p><code>RACStreams</code>官方定义<code>An abstract class representing any stream of values</code>，我翻译下RACStreams是展现任何数据流的一个抽象类。RACStreams通俗点讲就是上面那段话中<code>水管里面线性流动的、具有顺序的玻璃球</code>。RACStreams因为是一个抽象类，我们使用中很少直接接触到，我们一般是使用继承自RACStreams的<code>RACSignal</code>和<code>RACSequence</code>。对于RACSignal和RACSequence与RACStreams联系，我觉得可以直接用<a href="http://nshipster.cn/reactivecocoa/" target="_blank" rel="external">NShipster</a>中一句话：</p>
<blockquote>
<p>signal是push驱动的stream，sequence是pull驱动的stream。</p>
</blockquote>
<h2 id="RACSignal_and_RACSubscriber"><a href="#RACSignal_and_RACSubscriber" class="headerlink" title="RACSignal and RACSubscriber"></a>RACSignal and RACSubscriber</h2><p><code>RACSignal</code>是ReactiveCocoa的核心所在，有了它就能开始使用ReactiveCocoa。RACSignal通俗点讲就是上面那段话中所提到的<code>水龙头</code>，表示未来要到到达的值。比较类似于一个概念，叫做<code>future and promise</code>，大家可以自行去了解下。<br><code>RACSubscriber</code>是订阅者，通俗点说就是上面那段话中用来装玻璃球的<code>桶</code>。我们可以用一个更好的比喻来理解一下。把RACSignal比作插头，把RACSubscriber比作插座，插头负责去用电，插座负责去取点，插头插座配套才能使用。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.usernameTextField.rac_textSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h3 id="u51B7_u4FE1_u53F7_28Cold_29_u548C_u70ED_u4FE1_u53F7_28Hot_29"><a href="#u51B7_u4FE1_u53F7_28Cold_29_u548C_u70ED_u4FE1_u53F7_28Hot_29" class="headerlink" title="冷信号(Cold)和热信号(Hot)"></a>冷信号(Cold)和热信号(Hot)</h3><p>在上文中提到的插头插座比喻中，如果说只有插头，没有插座，即只有RACSignal，而没有RACSubscriber，则把RACSignal称之为冷信号，而冷信号默认是不进行任何操作的。只要加上RACSubscriber，就可以进行操作，这个时候RACSignal就被称作是热信号。如果说只有插座，没有插头，那么只要去找到插头就能解决问题。</p>
<h3 id="RACReplaySubject"><a href="#RACReplaySubject" class="headerlink" title="RACReplaySubject"></a>RACReplaySubject</h3><p>我们继续上文中的插头插座比喻，如果现在同时有多个插座在等待一个插头用电，那么我就要把这个插头多次拔下来插到所有的插座上。大家都不愿意重复这个操作，ReactiveCocoa提供了<code>RACReplaySubject</code>方法，保证<code>RACSignal</code>只触发一次。把需要send的value存起来，直接发送缓存数据。</p>
<h3 id="u8BE6_u89E3"><a href="#u8BE6_u89E3" class="headerlink" title="详解"></a>详解</h3><p>RACSignal一共会发送三种事件给RACSubscriber，RACSubscriber通过-subscribeNext:error:completed:对不同事件作出相应反应</p>
<ul>
<li>next 继续进行发送</li>
<li>error 出现错误  </li>
<li>completed 完成</li>
</ul>
<p>一个RACSignal会因为error和completed的出现而终止，即生命周期中只会有一个errot或者completed，但是却可以多次发送next事件。而我们接下来要讨论的就是如何来处理这些多次next事件。</p>
<h2 id="RACSequence"><a href="#RACSequence" class="headerlink" title="RACSequence"></a>RACSequence</h2><p><code>RACSequence</code>官方的解释是一组immutable且有序的values，很多人说把这个看做是<code>NSArray</code>。但是注意用词是<code>看做</code>，因为这些values的值是<code>懒加载</code>(只有需要的时候才加载)，这样sequence只有一部分被用到，会一定程度得提升性能。那么NSArray可以通过rac_sequence方法转换成RACSequence来调用RAC中的方法了。像Cocoa的集合类型一样，RACSequence不接受<code>nil</code>。</p>
<h2 id="map__u2013__u4FEE_u6539"><a href="#map__u2013__u4FEE_u6539" class="headerlink" title="map – 修改"></a>map – 修改</h2><p><code>map</code> calls its block with each user that’s fetched and returns a new. 解释一下就是将事件中获得的数据映射为你想要的对象，可以看做对玻璃球的重新包装。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[[[<span class="keyword">self</span>.usernameTextField.rac_textSignal map:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">    <span class="keyword">return</span> @(text.length);</div><div class="line"> &#125;]</div><div class="line"> subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</div><div class="line"> &#125;];</div></pre></td></tr></table></figure></p>
<h2 id="filter__u2013__u8FC7_u6EE4"><a href="#filter__u2013__u8FC7_u6EE4" class="headerlink" title="filter – 过滤"></a>filter – 过滤</h2><p><code>Filters</code> out values in the receiver that don’t pass the given test. 非常简单对事件中的内容进行过滤，可以看做不合要求的玻璃球进行拦击，不允许通过水管。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[[[<span class="keyword">self</span>.usernameTextField.rac_textSignal map:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">    <span class="keyword">return</span> @(text.length);</div><div class="line"> &#125;]</div><div class="line"> filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSNumber</span> *length) &#123;</div><div class="line">     <span class="keyword">return</span> [length intValue] &gt; <span class="number">3</span>;</div><div class="line"> &#125;]</div><div class="line"> subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</div><div class="line"> &#125;];</div></pre></td></tr></table></figure></p>
<h2 id="combineLatest__u2013__u7EC4_u5408"><a href="#combineLatest__u2013__u7EC4_u5408" class="headerlink" title="combineLatest – 组合"></a>combineLatest – 组合</h2><p><code>Combines</code> the latest values from the receiver and the given signal into RACTuples, once both have sent at least one next. 将一组事件组合为一个输出最新事件的signal。可以看做是对水管进行改造，使得任何时刻都输出最新的玻璃球。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">RACSignal *signUpActiveSignal = [RACSignal combineLatest:@[validUsernameSignal, validPasswordSignal]</div><div class="line">                                                  reduce:^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *usernameValid, <span class="built_in">NSNumber</span> *passwordValid)&#123;</div><div class="line">                                                      <span class="keyword">return</span> @([usernameValid boolValue] &amp;&amp; [passwordValid boolValue]);</div><div class="line">                                                  &#125;];</div></pre></td></tr></table></figure></p>
<h2 id="flatten__u2013__u5408_u5E76"><a href="#flatten__u2013__u5408_u5E76" class="headerlink" title="flatten – 合并"></a>flatten – 合并</h2><p><code>flatten</code>把事件进行合并，对于其中的内容都进行显示，来一个显示一个，可以交叉显示。可以看做把多个水管进行了合并，哪个水管中的玻璃球到了就放出玻璃球。</p>
<h2 id="flattenMap__u2013__u89E3_u51B3signal_of_signals"><a href="#flattenMap__u2013__u89E3_u51B3signal_of_signals" class="headerlink" title="flattenMap – 解决signal of signals"></a>flattenMap – 解决signal of signals</h2><p>Maps <code>block</code> across the values in the receiver and flattens the result.<br>这个问题首先要先解释一下。就是说事件完成block后有可能会返回signal的实例，这个时候外部信号中就会包含一个内部信号，这个时候使用map去讲信号转换为另一种信号，造成了嵌套的麻烦。所以说通过flattenMap将事件从内部信号发送到外部信号，并且映射到另外一个信号上去，这样这个过程就变得扁平化。Signal被按序的链接起来执行异步操作，而且不用嵌套block。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)signInSignal</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        [<span class="keyword">self</span>.signInService signInWithUsername:<span class="keyword">self</span>.usernameTextField.text</div><div class="line">                                      password:<span class="keyword">self</span>.passwordTextField.text</div><div class="line">                                      complete:^(<span class="built_in">BOOL</span> success) &#123;</div><div class="line">                                          [subscriber sendNext:@(success)];</div><div class="line">                                          [subscriber sendCompleted];</div><div class="line">                                      &#125;];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">[[[<span class="keyword">self</span>.signInButton rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>] flattenMap:^RACStream *(<span class="keyword">id</span> value) &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> signInSignal];</div><div class="line">&#125;] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Sign in result: %@"</span>, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<h2 id="u5FAA_u73AF_u5F15_u7528"><a href="#u5FAA_u73AF_u5F15_u7528" class="headerlink" title="循环引用"></a>循环引用</h2><p>ReactiveCocoa使用时大量的使用了block，而由于Ojective-C语言的内存管理机制使用的引用计数，会造成循环引用的问题。为了避免循环引用的问题，通常的解决办法是声明其中的一个变量为弱引用weak，将其赋值给self，在block中来使用这个弱引用的self，为了简单，通常使用了一个语法糖：<code>@weakify(self)</code>和<code>@strongify(self)</code>。</p>
<h2 id="u5E38_u7528_u5B8F_u5B9A_u4E49"><a href="#u5E38_u7528_u5B8F_u5B9A_u4E49" class="headerlink" title="常用宏定义"></a>常用宏定义</h2><ul>
<li><p>RAC()可以将信号的某个属性与其他的信号进行联动。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RAC(<span class="keyword">self</span>.submitButton.enabled) = [RACSignal combineLatest:@[<span class="keyword">self</span>.usernameField.rac_textSignal, <span class="keyword">self</span>.passwordField.rac_textSignal] reduce:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *userName, <span class="built_in">NSString</span> *password) &#123;</div><div class="line">    <span class="keyword">return</span> @(userName.length &gt;= <span class="number">6</span> &amp;&amp; password.length &gt;= <span class="number">6</span>);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
</li>
<li><p>RACObserve()监听信号的属性的改变，使用block的KVO</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[RACObserve(<span class="keyword">self</span>.textField, text) subscribeNext:^(<span class="built_in">NSString</span> *newName) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, newName);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><p><img src="http://7xp57v.com1.z0.glb.clouddn.com/coryphaei/mvvm.png" alt="MVVM"></p>
<h2 id="u4E3A_u4EC0_u4E48_u8981_u63D0_u5230MVVM"><a href="#u4E3A_u4EC0_u4E48_u8981_u63D0_u5230MVVM" class="headerlink" title="为什么要提到MVVM"></a>为什么要提到MVVM</h2><p>MVVM其实是MVC的变形框架，主要来解决目前iOS应用中日益增长的重量级Controller的问题。在你使用ReactiveCocoa的时候会发现将事件定义统一接口后确实方便了代码的编写，但是都在Controller中来进行使得Conttroller异常的臃肿。这个也就是为什么很多人写到ReactiveCocoa的时候一定会提到MVVM的原因，建议大家配合使用，将ReactiveCocoa处理事件的代码写在ViewModel中，这样也方便做测试，昨天听了LeanCloud智维大神的自动化和测试之后，也准备来探究一下，应该到时候会出一篇博客。</p>
<h2 id="u5173_u4E8EMVVM"><a href="#u5173_u4E8EMVVM" class="headerlink" title="关于MVVM"></a>关于MVVM</h2><p>关于MVVM，这里不做详细的讲解，不是本章的重点。但是可以给出几篇参考，有兴趣的同学可以去了解一下。</p>
<ul>
<li><a href="http://objccn.io/issue-13-1/" target="_blank" rel="external">MVVM 介绍</a></li>
<li><a href="http://www.infoq.com/cn/articles/rethinking-mvc-mvvm" target="_blank" rel="external">被误解的MVC和被神化的MVVM
</a></li>
</ul>
<h1 id="u6700_u540E"><a href="#u6700_u540E" class="headerlink" title="最后"></a>最后</h1><p>我尽管认真的学习了一周ReactiveCocoa，但是仍然还处在入门阶段，也许等我实战之后会有更多的体会和坑来告诉大家，但是这个是重框架，入门还是比较难的，我尽我所能的理解写下这个博客，希望能帮助大家入个门，同时我也给出几篇参考文章，希望对大家有帮助。</p>
<ul>
<li><a href="http://nshipster.cn/reactivecocoa/" target="_blank" rel="external">Reactive​Cocoa</a></li>
<li><a href="http://limboy.me/ios/2013/12/27/reactivecocoa-2.html" target="_blank" rel="external">说说ReactiveCocoa 2</a></li>
<li><a href="http://yulingtianxia.com/blog/2014/07/29/reactivecocoa/" target="_blank" rel="external">ReactiveCocoa学习笔记</a></li>
<li><a href="http://southpeak.github.io/blog/2014/08/02/reactivecocoazhi-nan-%5B%3F%5D-:xin-hao/" target="_blank" rel="external">ReactiveCocoa Tutorial – the Definitive Introduction: Part 1/2</a></li>
<li><a href="http://www.itiger.me/?p=38" target="_blank" rel="external">使用ReactiveCocoa实现iOS平台响应式编程</a></li>
<li><a href="http://blog.devtang.com/blog/2014/02/11/reactivecocoa-introduction/" target="_blank" rel="external">唐巧 ReactiveCocoa - iOS开发的新框架</a></li>
</ul>
<h1 id="u89C6_u9891"><a href="#u89C6_u9891" class="headerlink" title="视频"></a>视频</h1><iframe height="498" width="510" src="http://player.youku.com/embed/XMTQxOTIyOTQyMA==" frameborder="0" allowfullscreen></iframe>

<h1 id="update"><a href="#update" class="headerlink" title="update"></a>update</h1><ul>
<li>2015.12.22 上周六的时候，<a href="https://github.com/DeveloperLx" target="_blank" rel="external">DeveloperLx</a>讲了有关于ReactiveCocoa的很多干货，我写了一篇<a href="">博客</a>，大部分都是对他将的内容的整理和一点感悟。</li>
</ul>
<blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt=""><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2015/12/15/Objective-C_epoch--ReactiveCocoa_framwork/">http://yeziahehe.com/2015/12/15/Objective-C_epoch--ReactiveCocoa_framwork/</a></blockquote>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>很久之前我就准备写有关于ReactiveCocoa的文章，前面林林总总写过几篇，但是都是简单的讲述，并没]]>
    </summary>
    
      <category term="iOS" scheme="http://yeziahehe.com/tags/iOS/"/>
    
      <category term="ReactiveCocoa" scheme="http://yeziahehe.com/tags/ReactiveCocoa/"/>
    
      <category term="Objective-C" scheme="http://yeziahehe.com/tags/Objective-C/"/>
    
      <category term="技术" scheme="http://yeziahehe.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Travis CI自动构建Hexo静态博客]]></title>
    <link href="http://yeziahehe.com/2015/12/13/use_Travis_CI_auto_build_Hexo_static_blog/"/>
    <id>http://yeziahehe.com/2015/12/13/use_Travis_CI_auto_build_Hexo_static_blog/</id>
    <published>2015-12-13T15:35:55.000Z</published>
    <updated>2016-08-07T20:30:36.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>随着现在open source越来越火，更多的人开始注重技术知识的获取。不可否认，目前的信息传播速度非常之快，渠道也非常之多，对于知识获取的整理和理解是很多人都在做的一件事情。在这种情况下更多的人开始选择写博客，把自己认知记录下来，一是为了检验自己对于技术的理解，二是为了让更多的人去从你的博客中获取到有用的信息。</p>
<p>我2014年的时候自己买了域名，用<code>jekyll + GitHub Pages</code>搭建了自己的博客（目前正在考虑换到Hexo，而Coryphaei技术博客就是采用的Hexo）。我同样也了搭建我们公司的<a href="http://blog.coryphaei.com/" target="_blank" rel="external">技术博客</a>，大家有兴趣可以访问，我的很多干货也将发表到那边。</p>
<h1 id="u6280_u672F"><a href="#u6280_u672F" class="headerlink" title="技术"></a>技术</h1><p>Coryphaei技术博客采用的是<code>Hexo + GitHub Pages + Travis CI</code>的技术方案，实现了多人同时更新博客并且自动化构建。</p>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p><a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>是一款高效、简洁的静态博客框架，目前整个项目都开源在<a href="https://github.com/hexojs/hexo" target="_blank" rel="external">GitHub</a>上。因为部署极其简单，而且不需要数据库的支持，纯静态的模式，使得目前静态博客被越来越多的选择。关注与文章本身，创造出更有价值的文章才是每个写博客的人的初衷。</p>
<p>Hexo是由<a href="nodejs.org">Node.js</a>完成，需要集成Node.js的开发环境，这里不再赘述。接下来开始集成Hexo的开发环境，因为我是OS X，所以一下所有的均是基于OS X环境的搭建教程。</p>
<p>首先，需要配置基本的环境。</p>
<h3 id="cnpm"><a href="#cnpm" class="headerlink" title="cnpm"></a>cnpm</h3><blockquote>
<p>注意：npm因为qiang的原因，经常会出问题，我换成了taobao的cmpn镜像，taobao的cnpm镜像这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。</p>
</blockquote>
<p>安装方式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</div></pre></td></tr></table></figure></p>
<h3 id="Hexo_u57FA_u672C_u73AF_u5883"><a href="#Hexo_u57FA_u672C_u73AF_u5883" class="headerlink" title="Hexo基本环境"></a>Hexo基本环境</h3><p>Hexo基本环境的配置，步骤比较简单。</p>
<h4 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ cnpm install hexo-cli -g</div><div class="line">$ hexo init blog</div><div class="line">$ <span class="built_in">cd</span> blog</div><div class="line">$ cnpm install</div></pre></td></tr></table></figure>
<p>启动本地的服务器看下是否安装成功<code>hexo s</code>，浏览器打开<code>http://localhost:4000</code>。</p>
<h4 id="u4E3B_u9898_Next"><a href="#u4E3B_u9898_Next" class="headerlink" title="主题 Next"></a>主题 Next</h4><p>我采用的是<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">Next</a>主题，这个主题是国人写的，因为其简洁的特点，深受大家的喜欢。Next有官方出的<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">使用说明</a>，大家有问题可以先去浏览使用说明。</p>
<p>安装非常简单<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> blog</div><div class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</div></pre></td></tr></table></figure></p>
<p>启用 NexT 主题<br>克隆/下载 完成后，打开根目录下的_config.yml，找到<code>theme</code>字段，并将其值更改为<code>next</code>。<br>启动本地的服务器看下是否安装成功<code>hexo s</code>，浏览器打开<code>http://localhost:4000</code>。</p>
<h4 id="u57FA_u672C_u914D_u7F6E_u7684_u4E00_u4E9B_u4FEE_u6539"><a href="#u57FA_u672C_u914D_u7F6E_u7684_u4E00_u4E9B_u4FEE_u6539" class="headerlink" title="基本配置的一些修改"></a>基本配置的一些修改</h4><p>对于博客的基本配置的个性化定制，完全可以参照Next官方出的<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">使用说明</a>，我也附上我的 <a href="https://github.com/Coryphaei/coryphaei.github.io/blob/blog/_config.yml" target="_blank" rel="external">_config.yml</a> 和theme目录下的<a href="https://github.com/Coryphaei/coryphaei.github.io/blob/blog/themes/next/_config.yml" target="_blank" rel="external">themes/next/_config.yml</a>供大家参考。</p>
<p>到目前为止，整个Hexo的博客就搭建完毕。</p>
<h2 id="GitHub_Pages"><a href="#GitHub_Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h2><p>有关于GitHub Pages的问题，网上教程太多，大家可以自行google，这边就不在赘述。</p>
<h2 id="Travis_CI"><a href="#Travis_CI" class="headerlink" title="Travis CI"></a>Travis CI</h2><p>目前，自动化构建、持续集成的理念在整个计算行业非常的流行，大家更愿意去使用自动化代替手动，从而提高效率。</p>
<p><code>持续集成</code>的概念</p>
<blockquote>
<p>持续集成是一种软件开发实践。在持续集成中，团队成员频繁集成他们的工作成果，每人每天可能集成一次，甚至多次。每次集成会经过自动构建（包括自动测试）的检验，以尽快发现集成错误。许多团队发现这种方法可以显著减少集成引起的问题，并可以加快团队合作软件开发的速度。</p>
</blockquote>
<p>自动构建工具则是持续集成的一种出色实践。代码提交后，由软件自动完成代码的测试、构建，并将过程中状态与构建物产出才是持续集成的意义。</p>
<p><a href="https://travis-ci.org/" target="_blank" rel="external">Travis CI</a>就是一个在线的、分布式的持续集成服务，用来构建及测试在GitHub托管的代码。利用Travis CI 会在每一次push后生成一个虚拟机来执行事先安排好的自动构建任务，从来进行发布。</p>
<h3 id="u4E3A_u4EC0_u4E48_u4F7F_u7528"><a href="#u4E3A_u4EC0_u4E48_u4F7F_u7528" class="headerlink" title="为什么使用"></a>为什么使用</h3><p>Travis CI本身已经是很好的自动构建的工具，而这里使用的原因，本质上是因为Hexo本身并不能进行多人合作。Hexo的<code>hexo generate</code>和<code>hexo deploy</code>会自动渲染并提交到GitHub上，所以当你从别的电脑上clone的时候，clone下来的是渲染好的html的文章。就算我在两个电脑上同时搭建了环境，但是每次渲染的时候只会渲染本地的markdown文章，依然不能进行同步。有些人选择了使用百度云进行同步，每次写之前下载下来并覆盖，就能进行同步。不否认，这个方法对于一个人写博客，在工作和家的电脑还算是比较方便的，因为始终是一个人进行操作。而我们的博客是多人共同写的，所以说会存在各种冲突问题，于是想到了用Travis CI。</p>
<h3 id="u539F_u7406"><a href="#u539F_u7406" class="headerlink" title="原理"></a>原理</h3><p><img src="http://7xp57v.com1.z0.glb.clouddn.com/coryphaei/travis-hexo-flowing.png" alt="travis-hexo-flowing"></p>
<blockquote>
<p>图片引用自v2cc的<a href="http://v2cc.github.io/2015/09/02/unbelievable-workflow-autodeploy-hexo-by-travis/" target="_blank" rel="external">博客</a>，并且其对于流程的讲解也对我产生了很大的帮助，非常感谢。</p>
</blockquote>
<p>分析下思路：<br>前提：我们在之前博客搭建的repo下面，新建一个blog的分支，这个分支用来进行环境代码的备份，并且配置出<code>.travis.yml</code>进行自动化构建。</p>
<h4 id="User_-_push_-_26gt_3B_branch_blog"><a href="#User_-_push_-_26gt_3B_branch_blog" class="headerlink" title="User - push -&gt; branch blog"></a>User - push -&gt; branch blog</h4><p>将代码push到在GitHub上的博客中的blog分支。</p>
<h4 id="Dev_repo_-_sync_-_26gt_3B_Travis_CI"><a href="#Dev_repo_-_sync_-_26gt_3B_Travis_CI" class="headerlink" title="Dev repo - sync -&gt; Travis CI"></a>Dev repo - sync -&gt; Travis CI</h4><p>在branch blog中配置<code>.travis.yml</code>文件，在Travis CI中开启branch blog的同步开关，并启用<code>Build only if .travis.yml is present</code>项，这样能在repo中有多个branch时，让Travis CI只构建放置了<code>.travis.yml</code>文件的branch。</p>
<h4 id="Travis_CI_-_build_and_push_-_26gt_3B_Pages_repo"><a href="#Travis_CI_-_build_and_push_-_26gt_3B_Pages_repo" class="headerlink" title="Travis CI - build and push -&gt; Pages repo"></a>Travis CI - build and push -&gt; Pages repo</h4><p>Travis CI 的自动化构建完全依靠唯一的<code>.travis.yml</code>脚本文件。需要在此文件中添加构建环境、构建Hexo、生成博客及后续push到Pages repo的全部脚本。</p>
<h5 id="u751F_u6210SSH_Key"><a href="#u751F_u6210SSH_Key" class="headerlink" title="生成SSH Key"></a>生成SSH Key</h5><p>要做到Travis CI向Pages repo自动推送就必须用到Github SSH Key，这样做的目的是免去Hexo部署时候输入密码的步骤。生成SSH Key的操作参照GitHub的官网即可：<a href="https://help.github.com/articles/generating-ssh-keys/" target="_blank" rel="external">Github SSH Key</a>。</p>
<p>这样会得到<code>id_rsa.pub</code>和<code>id_rsa</code>两个秘钥，我们将<code>id_rsa.pub</code>添加到了github，下面要加密<code>id_rsa</code>这个私钥并且上传到Travis。</p>
<blockquote>
<p>注意：这个SSH key不应该是你账号的全局SSH Key，这样Travis CI就获得了你所有代码库的提交权限。仅仅只需要把SSH Key添加到当前repo的setting中的key下面即可。</p>
</blockquote>
<h5 id="Travis_CI__u73AF_u5883"><a href="#Travis_CI__u73AF_u5883" class="headerlink" title="Travis CI 环境"></a>Travis CI 环境</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ sudo cp ~/.ssh/id_rsa / <span class="comment">#将上一步得到的`id_rsa`复制到根目录下</span></div><div class="line">$ vim .travis.yml <span class="comment">#创建.travis.yml</span></div><div class="line">$ gem install travis <span class="comment">#安装Travis CI</span></div><div class="line">$ travis login --auto <span class="comment">#登录Travis CI，需要输入GitHub的账号密码</span></div><div class="line">$ travis encrypt-file ssh_key --add <span class="comment">#加密私钥并上传至Travis</span></div></pre></td></tr></table></figure>
<p>生成加密过得新秘钥<code>id_rsa.enc</code>, 并自动将branch blog中git的信息及解密秘钥的相关信息添加到<code>.travis.yml</code>中。然后手动删除私钥文件<code>id_rsa</code>， 以保证代码仓库的安全。</p>
<h5 id="SSH_u7684_u8BBE_u7F6E"><a href="#SSH_u7684_u8BBE_u7F6E" class="headerlink" title="SSH的设置"></a>SSH的设置</h5><p>在当前目录下新建文件<code>ssh_config</code>，内容为<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Host github.com</div><div class="line">  User git</div><div class="line">  StrictHostKeyChecking no</div><div class="line">  IdentityFile ~/.ssh/id_rsa</div><div class="line">  IdentitiesOnly yes</div></pre></td></tr></table></figure></p>
<p>修改<code>.travis.yml</code>中的命令，指定openssl解密后的生成位置，xxxxxxxxxx部分就是你的解密参数，不要去改动它。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- openssl aes-256-cbc -K <span class="variable">$encrypted_xxxxxxxxxx_key</span> -iv <span class="variable">$encrypted_xxxxxxxxxx_iv</span></div><div class="line">  -<span class="keyword">in</span> travis.enc -out ~/.ssh/id_rsa -d</div></pre></td></tr></table></figure></p>
<h5 id="u4FEE_u6539_u76EE_u5F55_u6743_u9650"><a href="#u4FEE_u6539_u76EE_u5F55_u6743_u9650" class="headerlink" title="修改目录权限"></a>修改目录权限</h5><p>紧接着在<code>.travis.yml</code>中修改目录权限<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- chmod 600 ~/.ssh/id_rsa</div></pre></td></tr></table></figure></p>
<h5 id="u5C06_u5BC6_u94A5_u52A0_u5165_u7CFB_u7EDF"><a href="#u5C06_u5BC6_u94A5_u52A0_u5165_u7CFB_u7EDF" class="headerlink" title="将密钥加入系统"></a>将密钥加入系统</h5><p>紧接着在<code>.travis.yml</code>中将密钥加入系统<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- <span class="built_in">eval</span> $(ssh-agent)</div><div class="line">- ssh-add ~/.ssh/id_rsa</div></pre></td></tr></table></figure></p>
<h5 id="u4FEE_u6539git_u4FE1_u606F"><a href="#u4FEE_u6539git_u4FE1_u606F" class="headerlink" title="修改git信息"></a>修改git信息</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- cp ssh_config ~/.ssh/config</div><div class="line">- git config --global user.name <span class="string">"username"</span></div><div class="line">- git config --global user.email username@example.com</div></pre></td></tr></table></figure>
<h5 id="u6DFB_u52A0_u5206_u652F_u4FE1_u606F"><a href="#u6DFB_u52A0_u5206_u652F_u4FE1_u606F" class="headerlink" title="添加分支信息"></a>添加分支信息</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">branches:</div><div class="line">  only:</div><div class="line">  - blog</div></pre></td></tr></table></figure>
<h5 id="u914D_u7F6EHexo"><a href="#u914D_u7F6EHexo" class="headerlink" title="配置Hexo"></a>配置Hexo</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">install:</div><div class="line">- npm install hexo-cli -g</div><div class="line">- npm install hexo --save</div><div class="line">- npm install</div><div class="line"></div><div class="line">script:</div><div class="line">- hexo clean</div><div class="line">- hexo d</div><div class="line">- hexo g</div></pre></td></tr></table></figure>
<p>这样就完成了<code>.travis.yml</code>的设置，这里是我的源文件<a href="https://github.com/Coryphaei/coryphaei.github.io/blob/blog/.travis.yml" target="_blank" rel="external">.travis.yml</a>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">language: node_js</div><div class="line">node_js:</div><div class="line">- <span class="string">'0.12'</span></div><div class="line">branches:</div><div class="line">  only:</div><div class="line">  - blog</div><div class="line">before_install:</div><div class="line">- openssl aes-256-cbc -K <span class="variable">$encrypted_b83a281ef741_key</span> -iv <span class="variable">$encrypted_b83a281ef741_iv</span></div><div class="line">  -<span class="keyword">in</span> id_rsa.enc -out ~/.ssh/id_rsa -d</div><div class="line">- chmod 600 ~/.ssh/id_rsa</div><div class="line">- <span class="built_in">eval</span> $(ssh-agent)</div><div class="line">- ssh-add ~/.ssh/id_rsa</div><div class="line">- cp ssh_config ~/.ssh/config</div><div class="line">- git config --global user.name <span class="string">"叶帆"</span></div><div class="line">- git config --global user.email yeziahehe@gmail.com</div><div class="line">- git <span class="built_in">clone</span> -b master git@github.com:Coryphaei/coryphaei.github.io.git .deploy_git</div><div class="line">install:</div><div class="line">- npm install hexo-cli -g</div><div class="line">- npm install</div><div class="line">- npm install hexo-generator-feed --save</div><div class="line">- npm install hexo-deployer-git --save</div><div class="line">script:</div><div class="line">- hexo clean</div><div class="line">- hexo g</div><div class="line">- hexo g</div><div class="line">- hexo d</div></pre></td></tr></table></figure>
<p>这个时候应该将其push到blog分支。</p>
<blockquote>
<p>注意，要删除themes/next/.git文件，否则会导致主题传不上去，渲染后首页空白的问题。</p>
</blockquote>
<h4 id="View_the_pages"><a href="#View_the_pages" class="headerlink" title="View the pages"></a>View the pages</h4><p>打开首页，就能看到已经发布的最新博客。</p>
<h1 id="u95EE_u9898"><a href="#u95EE_u9898" class="headerlink" title="问题"></a>问题</h1><p>上述的所有步骤完成后，应该就已经成功了。我这边列举下我遇到的一些问题，希望能帮到大家。大家有任何问题也可以直接评论，我会第一时间回复。</p>
<ul>
<li><p><code>.travis.yml</code>中的注释问题<br><img src="http://7xp57v.com1.z0.glb.clouddn.com/coryphaei/travis_yml_comment.png" alt="travis_yml_comment"><br>一开始的时候我在<code>.travis.yml</code>中的注释用的是<code>//</code>，结果一直导致<code>missing config</code>。后来才知道YAML中注释应该用<code>#</code>。</p>
</li>
<li><p>首页无内容<br>一开始的时候我的首页一片空白，index.html中也是空的，原因就是因为主题Next是从GitHub上clone下来的，里面会存在<code>.git</code>文件，所以push到blog分支的时候千万要注意删除掉next文件夹中的<code>.git</code>文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> blog/themes/next <span class="comment">#到next主题文件夹下</span></div><div class="line">ls -a <span class="comment">#显示所有文件</span></div><div class="line">rm .git <span class="comment">#删除.git文件</span></div><div class="line">ls -a <span class="comment">#确认删除</span></div></pre></td></tr></table></figure>
</li>
<li><p>next主题会导致首页只显示最新的文章<br>很多人遇到发布后首页只显示最新的一篇文章，next主题<a href="https://github.com/iissnan/hexo-theme-next/issues/535" target="_blank" rel="external">issue</a>中也有提到这个。</p>
</li>
</ul>
<p>解决办法就是<code>hexo g</code>命令做两遍，这个也是为什么我<code>.travis.yml</code>中的Hexo配置命令写了两遍的原因。被这个问题纠缠了很久，希望写出来能帮到大家，如果你没有问题就不需要在<code>.travis.yml</code>中写两遍命令。</p>
<h1 id="u7ED3_u8BED"><a href="#u7ED3_u8BED" class="headerlink" title="结语"></a>结语</h1><p>这个是我搭建这个博客写的第一篇文章，我也发现我这次解决问题回去弄个明白，回想之前写的博客，其实干货真的很少，知识也很肤浅，这次搭建博客-发现问题-解决问题给了我很好的体验，也让我学到了很多，我会尽可能的去写很多的干货去和大家分享！共勉！</p>
<blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt=""><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2015/12/13/use_Travis_CI_auto_build_Hexo_static_blog/">http://yeziahehe.com/2015/12/13/use_Travis_CI_auto_build_Hexo_static_blog/</a></blockquote>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>随着现在open source越来越火，更多的人开始注重技术知识的获取。不可否认，目前的信息传播速度非常]]>
    </summary>
    
      <category term="hexo" scheme="http://yeziahehe.com/tags/hexo/"/>
    
      <category term="Travis CI" scheme="http://yeziahehe.com/tags/Travis-CI/"/>
    
      <category term="blog" scheme="http://yeziahehe.com/categories/blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[博客迁移]]></title>
    <link href="http://yeziahehe.com/2015/12/12/blog_trasfer/"/>
    <id>http://yeziahehe.com/2015/12/12/blog_trasfer/</id>
    <published>2015-12-12T15:45:56.000Z</published>
    <updated>2016-09-02T03:09:48.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u7F18_u7531"><a href="#u7F18_u7531" class="headerlink" title="缘由"></a>缘由</h1><p>最近开始搭建公司的<a href="http://blog.coryphaei.com" target="_blank" rel="external">博客</a>，了解到了<a href="http://hexo.io" target="_blank" rel="external">Hexo</a>，一款非常优雅的静态博客。我之前的博客就是使用<code>jekyll</code>静态博客，但是jekyll的theme实在是不和我的胃口，自己也没有好好经营，再加上自己做了修改后Bug百出，所以催生了我转向Hexo的阵营。</p>
<h1 id="u5173_u4E8E_u535A_u5BA2"><a href="#u5173_u4E8E_u535A_u5BA2" class="headerlink" title="关于博客"></a>关于博客</h1><p>最近搭建完了公司的博客后，突然开始注重博客的质量，几个小伙伴一起写难免会认真起来。我花了很久写了<a href="http://yeziahehe.com/2015/12/13/2015-12-13-%E4%BD%BF%E7%94%A8Travis%20CI%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BAHexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/">使用Travis CI自动构建Hexo静态博客</a>这篇博客，当我写完的时候我意识到这次写博客我确实参与其中，把这一系列的问题都搞得很透彻。在GitHub的Hexo和hexo-theme-next中提了issue，把可能出现的问题都发现了一遍，也都解决了一遍，这下我可以完全打包票，下次搭建Hexo的博客肯定能够兵来将挡，水来土掩。我很享受这个过程，也意识到写出好的博客才能体现博客的价值，否则就是在浪费时间。</p>
<h1 id="u53CD_u601D"><a href="#u53CD_u601D" class="headerlink" title="反思"></a>反思</h1><p>在这次博客的迁移和公司博客的搭建中，我清楚认识到几个问题：</p>
<ul>
<li>博客的质量很重要<br>博客首先的根本目的是解决问题，检验解决问题最关键就是你能不能把解决问题的过程说清楚。所以说博客的质量就反应了你对于问题的理解程度，我现在认识到一篇好的博客，一篇完整的博客可以给正在问题的人带来太多解惑的可能，也帮他们大量的节约了时间。</li>
<li>多思考，少而精<br>我以前写博客，也是从一个问题出发。但是以前我并没有去弄懂问题的原理，而是去参考别人的博客，采用了一种<code>很好的方式--堆砌</code>。然而写出的文章，没有灵魂，别人也不能从你的文章获取到一点有用的信息，都是老生常谈，并不是实践出真知的产物。我感触很深的是这次Hexo+Travis CI搭建的时候遇到了很多问题，但是我花了两个晚上持之以恒的在解决这些问题，一直在思考问题，然后用了一个下午的时间在图书馆把文章整理出来了。我收获很大，我觉得我顿悟了学习的本质。</li>
</ul>
<h1 id="u4EE5_u540E"><a href="#u4EE5_u540E" class="headerlink" title="以后"></a>以后</h1><p>这篇博客的是个分水岭，新的主题，也是新的开始。<br>之前的博客，我都不准备删掉，我觉得那个青涩的年纪写下的没有太多参考价值的文章，但是它却是我成长的见证。<br>从这篇博客以后，我肯定尽可能的去写有质量的文章，我希望自己能够做到，也欢迎大家监督。</p>
<blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt=""><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2015/12/12/blog_trasfer/">http://yeziahehe.com/2015/12/12/blog_trasfer/</a></blockquote>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u7F18_u7531"><a href="#u7F18_u7531" class="headerlink" title="缘由"></a>缘由</h1><p>最近开始搭建公司的<a href="http://blog.coryphaei.com" target=]]>
    </summary>
    
      <category term="随想" scheme="http://yeziahehe.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
      <category term="随想" scheme="http://yeziahehe.com/categories/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
</feed>
